<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electrical Concepts - Interactive Physics Experience</title>
    
    <meta name="description" content="Interactive electrical physics visualization with hyperrealistic elements and accurate calculations">
    <meta name="keywords" content="physics, electricity, circuits, visualization, educational">
    <meta name="author" content="Interactive Physics">
    
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E⚡%3C/text%3E%3C/svg%3E">
    
    <!-- Cartesia Voice Integration -->
    <script src="cartesia-config.js"></script>
    
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        :root {
            --primary: #1a1a1a;
            --secondary: #23272e;
            --accent: #4a9eff;
            --text: #fff;
            --glow: #4a9eff;
            --success: #2ecc71;
            --danger: #ff4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
            font-size: 16px;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
            background: var(--primary);
            color: var(--text);
            overflow-x: hidden;
            line-height: 1.6;
        }

        /* === LOADING SCREEN === */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, var(--secondary) 0%, var(--primary) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 1s ease-out, visibility 1s ease-out;
        }

        #loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loading-content {
            text-align: center;
            max-width: 400px;
        }

        .physics-loader {
            width: 120px;
            height: 120px;
            margin: 0 auto 2rem;
            position: relative;
        }

        .atom-nucleus {
            width: 20px;
            height: 20px;
            background: var(--accent);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px var(--accent);
            animation: nucleusPulse 2s ease-in-out infinite;
        }

        .electron-orbit {
            position: absolute;
            border: 2px solid rgba(74, 158, 255, 0.3);
            border-radius: 50%;
            animation: orbitRotate 3s linear infinite;
        }

        .orbit-1 {
            width: 60px;
            height: 60px;
            top: 30px;
            left: 30px;
        }

        .orbit-2 {
            width: 90px;
            height: 90px;
            top: 15px;
            left: 15px;
            animation-duration: 4s;
            animation-direction: reverse;
        }

        .orbit-3 {
            width: 120px;
            height: 120px;
            top: 0;
            left: 0;
            animation-duration: 5s;
        }

        .electron {
            width: 8px;
            height: 8px;
            background: var(--danger);
            border-radius: 50%;
            position: absolute;
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 10px var(--danger);
        }

        @keyframes nucleusPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        @keyframes orbitRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .loading-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, var(--accent), var(--danger));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .loading-subtitle {
            font-size: 1.1rem;
            opacity: 0.8;
            margin-bottom: 2rem;
        }

        .progress-container {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--danger));
            width: 0%;
            transition: width 0.3s ease;
            animation: progressGlow 2s ease-in-out infinite;
        }

        @keyframes progressGlow {
            0%, 100% { box-shadow: 0 0 5px rgba(74, 158, 255, 0.5); }
            50% { box-shadow: 0 0 20px rgba(74, 158, 255, 0.8); }
        }

        /* === NAVIGATION === */
        .navigation {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(74, 158, 255, 0.2);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-brand {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .nav-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(74, 158, 255, 0.1);
            color: var(--accent);
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nav-btn:hover {
            background: rgba(74, 158, 255, 0.2);
            transform: scale(1.1);
        }

        .section-counter {
            color: var(--accent);
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        /* === PROGRESS DOTS === */
        .progress-indicator {
            position: fixed;
            left: 2rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .progress-dot.active {
            background: var(--accent);
            box-shadow: 0 0 15px var(--accent);
            transform: scale(1.3);
        }

        .progress-dot:hover::after {
            content: attr(data-section);
            position: absolute;
            left: 2rem;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.9rem;
            white-space: nowrap;
            pointer-events: none;
            border: 1px solid var(--accent);
        }

        /* === MAIN CONTAINER === */
        .main-container {
            padding-top: 80px;
            min-height: 100vh;
        }

        .content-section {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            opacity: 0;
            transform: translateY(50px);
            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .content-section.active {
            opacity: 1;
            transform: translateY(0);
        }

        .section-wrapper {
            width: 100%;
            max-width: 1400px;
            display: grid;
            grid-template-columns: 1fr 600px;
            gap: 3rem;
            align-items: center;
        }

        .content-panel {
            background: rgba(35, 39, 46, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(74, 158, 255, 0.2);
            border-radius: 20px;
            padding: 3rem;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .section-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--accent), var(--danger));
            font-size: 1.5rem;
            font-weight: 700;
            color: white;
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 600;
            opacity: 0.9;
            color: var(--accent);
        }

        .main-title {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            background: linear-gradient(45deg, #ffffff, var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1.2;
        }

        .description {
            font-size: 1.2rem;
            line-height: 1.8;
            margin-bottom: 2rem;
            opacity: 0.9;
        }

        .equation-panel {
            background: rgba(74, 158, 255, 0.1);
            border: 1px solid rgba(74, 158, 255, 0.3);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .equation {
            font-size: 2rem;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .equation-description {
            font-size: 1rem;
            opacity: 0.8;
        }

        .interactive-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .interactive-btn {
            padding: 0.8rem 1.5rem;
            border: 2px solid var(--accent);
            background: transparent;
            color: var(--accent);
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .interactive-btn:hover {
            background: var(--accent);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(74, 158, 255, 0.3);
        }

        /* === VISUALIZATION PANEL === */
        .visualization-panel {
            background: var(--secondary);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(74, 158, 255, 0.2);
            height: 600px;
            overflow: hidden;
            position: relative;
        }

        .visualization-canvas {
            width: 100%;
            height: 100%;
            border-radius: 15px;
            background: var(--primary);
            display: block;
        }

        .visualization-container {
            width: 100%;
            height: 100%;
            position: relative;
            border-radius: 15px;
            background: var(--primary);
            overflow: hidden;
            cursor: grab;
        }
        
        .visualization-container:active {
            cursor: grabbing;
        }
        
        .viz-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            display: flex;
            gap: 0.5rem;
        }
        
        .viz-control-btn {
            width: 30px;
            height: 30px;
            border: 1px solid rgba(74, 158, 255, 0.5);
            background: rgba(26, 26, 26, 0.8);
            color: var(--accent);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .viz-control-btn:hover {
            background: rgba(74, 158, 255, 0.2);
            border-color: var(--accent);
        }
        
        .viz-hint {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            background: rgba(26, 26, 26, 0.8);
            padding: 0.5rem;
            border-radius: 6px;
            border: 1px solid rgba(74, 158, 255, 0.3);
        }

        /* === MODAL STYLES === */
        .demo-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .demo-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .demo-modal-content {
            background: var(--secondary);
            border-radius: 20px;
            width: 90vw;
            height: 90vh;
            max-width: 1200px;
            position: relative;
            border: 2px solid var(--accent);
            overflow: hidden;
        }

        .demo-modal-header {
            background: var(--primary);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(74, 158, 255, 0.2);
        }

        .demo-modal-title {
            color: var(--accent);
            font-size: 1.5rem;
            font-weight: 600;
        }

        .demo-close-btn {
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }

        .demo-close-btn:hover {
            background: var(--accent);
            color: white;
        }

        .demo-frame {
            width: 100%;
            height: calc(100% - 80px);
            border: none;
            background: white;
        }

        /* Add responsive iframe styling */
        @media (max-width: 768px) {
            .demo-modal-content {
                width: 95vw;
                height: 95vh;
            }
            
            .demo-frame {
                height: calc(100% - 60px);
            }
            
            .demo-modal-header {
                padding: 0.5rem 1rem;
            }
            
            .demo-modal-title {
                font-size: 1.2rem;
            }
        }

        /* === COMPLETION MODAL === */
        .completion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }

        .completion-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .completion-content {
            background: linear-gradient(135deg, var(--secondary), #2a3060);
            border-radius: 20px;
            padding: 3rem;
            text-align: center;
            max-width: 500px;
            border: 1px solid var(--accent);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }

        .achievement-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .completion-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--accent);
        }

        .completion-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }

        .action-btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .action-btn.primary {
            background: var(--accent);
            color: white;
        }

        .action-btn.secondary {
            background: transparent;
            color: var(--accent);
            border: 2px solid var(--accent);
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(74, 158, 255, 0.3);
        }

        /* === RESPONSIVE === */
        @media (max-width: 1200px) {
            .section-wrapper {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
                gap: 2rem;
            }
            
            .visualization-panel {
                height: 500px;
            }
        }

        @media (max-width: 768px) {
            .navigation {
                padding: 1rem;
            }
            
            .nav-brand {
                font-size: 1.2rem;
            }
            
            .content-section {
                padding: 1rem;
            }
            
            .content-panel {
                padding: 2rem;
            }
            
            .main-title {
                font-size: 2rem;
            }
            
            .description {
                font-size: 1rem;
            }
            
            .progress-indicator {
                left: 1rem;
            }
            
            .interactive-controls {
                flex-direction: column;
            }
            
            .visualization-panel {
                height: 400px;
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-content">
            <div class="physics-loader">
                <div class="atom-nucleus"></div>
                <div class="electron-orbit orbit-1">
                    <div class="electron"></div>
                </div>
                <div class="electron-orbit orbit-2">
                    <div class="electron"></div>
                </div>
                <div class="electron-orbit orbit-3">
                    <div class="electron"></div>
                </div>
            </div>
            <h1 class="loading-title">Electrical Concepts</h1>
            <p class="loading-subtitle">Loading Interactive Physics Experience...</p>
            <div class="progress-container">
                <div class="progress-bar" id="loading-progress"></div>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <nav class="navigation">
        <div class="nav-brand">
            ⚡ Electrical Concepts
        </div>
        <div class="nav-controls">
            <div class="section-counter">
                <span id="current-section">1</span> / <span id="total-sections">9</span>
            </div>
            <button class="nav-btn" id="audio-btn" title="Toggle Audio">🔊</button>
            <button class="nav-btn" id="fullscreen-btn" title="Fullscreen">⛶</button>
            <button class="nav-btn" id="home-btn" title="Home">🏠</button>
        </div>
    </nav>

    <!-- Progress Indicator -->
    <div class="progress-indicator">
        <div class="progress-dot active" data-section="Electric Charge" data-index="0"></div>
        <div class="progress-dot" data-section="Electric Current" data-index="1"></div>
        <div class="progress-dot" data-section="Resistance" data-index="2"></div>
        <div class="progress-dot" data-section="Voltage" data-index="3"></div>
        <div class="progress-dot" data-section="Ohm's Law" data-index="4"></div>
        <div class="progress-dot" data-section="Circuit Components" data-index="5"></div>
        <div class="progress-dot" data-section="Circuit Configurations" data-index="6"></div>
        <div class="progress-dot" data-section="Heating Effects" data-index="7"></div>
        <div class="progress-dot" data-section="Electric Power" data-index="8"></div>
    </div>

    <!-- Main Content Container -->
    <div class="main-container">
        
        <!-- Section 1: Electric Charge -->
        <section class="content-section active" data-section="0">
            <div class="section-wrapper">
                <div class="content-panel">
                    <div class="section-header">
                        <div class="section-number">01</div>
                        <div class="section-title">Electric Charge</div>
                    </div>
                    <h1 class="main-title">Foundation of Electricity</h1>
                    <p class="description">
                        Everything begins with electric charge - the fundamental property that creates 
                        all electrical phenomena. Observe how positive and negative charges interact 
                        through Coulomb's force with realistic visualization.
                    </p>
                    <div class="equation-panel">
                        <div class="equation">F = k(q₁q₂)/r²</div>
                        <div class="equation-description">Coulomb's Law - Force between two charges</div>
                    </div>
                    <div class="interactive-controls">
                        <button class="interactive-btn" onclick="openDemoModal('charge.html', 'Electric Charge Demo')">Interactive Demo</button>
                        <button class="interactive-btn" onclick="nextSection()">Continue →</button>
                    </div>
                </div>
                <div class="visualization-panel">
                    <div class="visualization-container" id="charge-viz">
                        <canvas class="visualization-canvas" id="charge-canvas"></canvas>
                        <div class="viz-controls">
                            <button class="viz-control-btn" onclick="resetCameraView('charge')" title="Reset View">↻</button>
                            <button class="viz-control-btn" onclick="toggleAnimation('charge')" title="Toggle Animation" id="charge-play">⏸</button>
                        </div>
                        <div class="viz-hint">Click and drag to rotate • Scroll to zoom</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 2: Electric Current -->
        <section class="content-section" data-section="1">
            <div class="section-wrapper">
                <div class="content-panel">
                    <div class="section-header">
                        <div class="section-number">02</div>
                        <div class="section-title">Electric Current</div>
                    </div>
                    <h1 class="main-title">Flow of Electrons</h1>
                    <p class="description">
                        When charges move, they create electric current. Watch electrons 
                        drift through conductors with accurate drift velocities and 
                        thermal motion based on real physics.
                    </p>
                    <div class="equation-panel">
                        <div class="equation">I = Q/t = nAv_d e</div>
                        <div class="equation-description">Current as charge flow rate and drift velocity</div>
                    </div>
                    <div class="interactive-controls">
                        <button class="interactive-btn" onclick="openDemoModal('electric-current.html', 'Electric Current Demo')">Interactive Demo</button>
                        <button class="interactive-btn" onclick="nextSection()">Continue →</button>
                    </div>
                </div>
                <div class="visualization-panel">
                    <div class="visualization-container" id="current-viz">
                        <canvas class="visualization-canvas" id="current-canvas"></canvas>
                        <div class="viz-controls">
                            <button class="viz-control-btn" onclick="resetCameraView('current')" title="Reset View">↻</button>
                            <button class="viz-control-btn" onclick="toggleAnimation('current')" title="Toggle Animation" id="current-play">⏸</button>
                        </div>
                        <div class="viz-hint">Drag to rotate • Zoom to see electron flow</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: Resistance -->
        <section class="content-section" data-section="2">
            <div class="section-wrapper">
                <div class="content-panel">
                    <div class="section-header">
                        <div class="section-number">03</div>
                        <div class="section-title">Electrical Resistance</div>
                    </div>
                    <h1 class="main-title">Opposition to Flow</h1>
                    <p class="description">
                        Not all materials conduct electricity equally. Experience how different materials 
                        resist current flow through electron-atom collisions, with accurate material 
                        properties and temperature dependencies.
                    </p>
                    <div class="equation-panel">
                        <div class="equation">R = ρL/A</div>
                        <div class="equation-description">Resistance depends on material and geometry</div>
                    </div>
                    <div class="interactive-controls">
                        <button class="interactive-btn" onclick="openDemoModal('resistance.html', 'Resistance Demo')">Material Demo</button>
                        <button class="interactive-btn" onclick="openDemoModal('factors-affecting.html', 'Factors Affecting Resistance')">Affecting Factors</button>
                        <button class="interactive-btn" onclick="nextSection()">Continue →</button>
                    </div>
                </div>
                <div class="visualization-panel">
                    <div class="visualization-container" id="resistance-viz">
                        <canvas class="visualization-canvas" id="resistance-canvas"></canvas>
                        <div class="viz-controls">
                            <button class="viz-control-btn" onclick="resetCameraView('resistance')" title="Reset View">↻</button>
                            <button class="viz-control-btn" onclick="toggleAnimation('resistance')" title="Toggle Animation" id="resistance-play">⏸</button>
                        </div>
                        <div class="viz-hint">Rotate to see heat generation • Watch electron collisions</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 4: Voltage -->
        <section class="content-section" data-section="3">
            <div class="section-wrapper">
                <div class="content-panel">
                    <div class="section-header">
                        <div class="section-number">04</div>
                        <div class="section-title">Electric Voltage</div>
                    </div>
                    <h1 class="main-title">The Driving Force</h1>
                    <p class="description">
                        Voltage is the electric potential difference that drives current through circuits. 
                        See realistic voltage sources and electric field gradients that push 
                        charges through resistance.
                    </p>
                    <div class="equation-panel">
                        <div class="equation">V = W/Q = ∫E·dl</div>
                        <div class="equation-description">Voltage as work per charge and electric field integral</div>
                    </div>
                    <div class="interactive-controls">
                        <button class="interactive-btn" onclick="openDemoModal('voltage.html', 'Electric Voltage Demo')">Potential Demo</button>
                        <button class="interactive-btn" onclick="nextSection()">Continue →</button>
                    </div>
                </div>
                <div class="visualization-panel">
                    <div class="visualization-container" id="voltage-viz">
                        <canvas class="visualization-canvas" id="voltage-canvas"></canvas>
                        <div class="viz-controls">
                            <button class="viz-control-btn" onclick="resetCameraView('voltage')" title="Reset View">↻</button>
                            <button class="viz-control-btn" onclick="toggleAnimation('voltage')" title="Toggle Animation" id="voltage-play">⏸</button>
                        </div>
                        <div class="viz-hint">Explore 3D potential field • See voltage gradients</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 5: Ohm's Law -->
        <section class="content-section" data-section="4">
            <div class="section-wrapper">
                <div class="content-panel">
                    <div class="section-header">
                        <div class="section-number">05</div>
                        <div class="section-title">Ohm's Law</div>
                    </div>
                    <h1 class="main-title">The Universal Relationship</h1>
                    <p class="description">
                        Ohm's Law reveals the fundamental relationship between voltage, current, and 
                        resistance. This simple yet powerful equation governs all electrical circuits 
                        with precise mathematical accuracy.
                    </p>
                    <div class="equation-panel">
                        <div class="equation">V = I × R</div>
                        <div class="equation-description">The foundational law of electrical engineering</div>
                    </div>
                    <div class="interactive-controls">
                        <button class="interactive-btn" onclick="openDemoModal('ohms-law.html', 'Ohms Law Demo')">Interactive Demo</button>
                        <button class="interactive-btn" onclick="nextSection()">Continue →</button>
                    </div>
                </div>
                <div class="visualization-panel">
                    <div class="visualization-container" id="ohms-viz">
                        <canvas class="visualization-canvas" id="ohms-canvas"></canvas>
                        <div class="viz-controls">
                            <button class="viz-control-btn" onclick="resetCameraView('ohms')" title="Reset View">↻</button>
                            <button class="viz-control-btn" onclick="toggleAnimation('ohms')" title="Toggle Animation" id="ohms-play">⏸</button>
                        </div>
                        <div class="viz-hint">Rotate circuit • See V=IR relationship in 3D</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 6: Circuit Components -->
        <section class="content-section" data-section="5">
            <div class="section-wrapper">
                <div class="content-panel">
                    <div class="section-header">
                        <div class="section-number">06</div>
                        <div class="section-title">Circuit Components</div>
                    </div>
                    <h1 class="main-title">Building Blocks</h1>
                    <p class="description">
                        Electrical circuits are built from various components, each with unique properties. 
                        Explore resistors, capacitors, inductors, and other fundamental components 
                        that make modern electronics possible.
                    </p>
                    <div class="equation-panel">
                        <div class="equation">V_R = IR, Q = CV, V_L = L(dI/dt)</div>
                        <div class="equation-description">Fundamental component relationships</div>
                    </div>
                    <div class="interactive-controls">
                        <button class="interactive-btn" onclick="openDemoModal('circuit-components.html', 'Circuit Components Demo')">Component Explorer</button>
                        <button class="interactive-btn" onclick="nextSection()">Continue →</button>
                    </div>
                </div>
                <div class="visualization-panel">
                    <div class="visualization-container" id="components-viz">
                        <canvas class="visualization-canvas" id="components-canvas"></canvas>
                        <div class="viz-controls">
                            <button class="viz-control-btn" onclick="resetCameraView('components')" title="Reset View">↻</button>
                            <button class="viz-control-btn" onclick="toggleAnimation('components')" title="Toggle Animation" id="components-play">⏸</button>
                        </div>
                        <div class="viz-hint">Examine 3D components • See internal structure</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 7: Circuit Configurations -->
        <section class="content-section" data-section="6">
            <div class="section-wrapper">
                <div class="content-panel">
                    <div class="section-header">
                        <div class="section-number">07</div>
                        <div class="section-title">Circuit Configurations</div>
                    </div>
                    <h1 class="main-title">Series vs Parallel</h1>
                    <p class="description">
                        Components can be connected in series or parallel, creating dramatically 
                        different behaviors. Compare side-by-side how current divides and voltage 
                        drops in each configuration.
                    </p>
                    <div class="equation-panel">
                        <div class="equation">R_s = R₁+R₂ | 1/R_p = 1/R₁+1/R₂</div>
                        <div class="equation-description">Series and parallel resistance combinations</div>
                    </div>
                    <div class="interactive-controls">
                        <button class="interactive-btn" onclick="openDemoModal('circuit-configurations.html', 'Circuit Configurations Demo')">Configuration Demo</button>
                        <button class="interactive-btn" onclick="nextSection()">Continue →</button>
                    </div>
                </div>
                <div class="visualization-panel">
                    <div class="visualization-container" id="configurations-viz">
                        <canvas class="visualization-canvas" id="configurations-canvas"></canvas>
                        <div class="viz-controls">
                            <button class="viz-control-btn" onclick="resetCameraView('configurations')" title="Reset View">↻</button>
                            <button class="viz-control-btn" onclick="toggleAnimation('configurations')" title="Toggle Animation" id="configurations-play">⏸</button>
                        </div>
                        <div class="viz-hint">Compare configurations • Rotate to analyze current paths</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 8: Heating Effects -->
        <section class="content-section" data-section="7">
            <div class="section-wrapper">
                <div class="content-panel">
                    <div class="section-header">
                        <div class="section-number">08</div>
                        <div class="section-title">Heating Effects</div>
                    </div>
                    <h1 class="main-title">Energy Transformation</h1>
                    <p class="description">
                        When current flows through resistance, electrical energy transforms into 
                        heat energy. Watch realistic heating elements glow with accurate 
                        temperature calculations and thermal radiation effects.
                    </p>
                    <div class="equation-panel">
                        <div class="equation">P = I²R = V²/R</div>
                        <div class="equation-description">Joule heating power dissipation</div>
                    </div>
                    <div class="interactive-controls">
                        <button class="interactive-btn" onclick="openDemoModal('heating-effect.html', 'Heating Effects Demo')">Heating Demo</button>
                        <button class="interactive-btn" onclick="nextSection()">Continue →</button>
                    </div>
                </div>
                <div class="visualization-panel">
                    <div class="visualization-container" id="heating-viz">
                        <canvas class="visualization-canvas" id="heating-canvas"></canvas>
                        <div class="viz-controls">
                            <button class="viz-control-btn" onclick="resetCameraView('heating')" title="Reset View">↻</button>
                            <button class="viz-control-btn" onclick="toggleAnimation('heating')" title="Toggle Animation" id="heating-play">⏸</button>
                        </div>
                        <div class="viz-hint">See thermal radiation • Watch temperature distribution</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 9: Electric Power -->
        <section class="content-section" data-section="8">
            <div class="section-wrapper">
                <div class="content-panel">
                    <div class="section-header">
                        <div class="section-number">09</div>
                        <div class="section-title">Electric Power</div>
                    </div>
                    <h1 class="main-title">Energy and Efficiency</h1>
                    <p class="description">
                        Electric power is the rate of energy transfer in electrical systems. 
                        From power grids to batteries, understand power flow with realistic 
                        devices showing efficiency and energy conservation.
                    </p>
                    <div class="equation-panel">
                        <div class="equation">P = V × I = Energy/Time</div>
                        <div class="equation-description">Power as rate of energy transfer</div>
                    </div>
                    <div class="interactive-controls">
                        <button class="interactive-btn" onclick="openDemoModal('electric-power.html', 'Electric Power Demo')">Power Analysis</button>
                        <button class="interactive-btn" onclick="showCompletion()">Complete Experience</button>
                    </div>
                </div>
                <div class="visualization-panel">
                    <div class="visualization-container" id="power-viz">
                        <canvas class="visualization-canvas" id="power-canvas"></canvas>
                        <div class="viz-controls">
                            <button class="viz-control-btn" onclick="resetCameraView('power')" title="Reset View">↻</button>
                            <button class="viz-control-btn" onclick="toggleAnimation('power')" title="Toggle Animation" id="power-play">⏸</button>
                        </div>
                        <div class="viz-hint">Explore power flow • See energy transformations</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Completion Modal -->
    <div class="completion-modal" id="completion-modal">
        <div class="completion-content">
            <div class="achievement-icon">⚡</div>
            <h2 class="completion-title">Electrical Mastery Complete!</h2>
            <p>You've mastered the fundamental principles of electrical engineering with scientifically accurate interactive visualizations.</p>
            <div class="completion-actions">
                <button class="action-btn primary" onclick="restartExperience()">Experience Again</button>
                <button class="action-btn secondary" onclick="exploreMore()">Explore More Physics</button>
            </div>
        </div>
    </div>

    <!-- Demo Modal -->
    <div class="demo-modal" id="demo-modal">
        <div class="demo-modal-content">
            <div class="demo-modal-header">
                <h3 class="demo-modal-title" id="demo-modal-title">Interactive Demo</h3>
                <button class="demo-close-btn" onclick="closeDemoModal()">×</button>
            </div>
            <iframe class="demo-frame" id="demo-frame" src=""></iframe>
        </div>
    </div>

    <script>
        class ElectricalConceptsExperience {
            constructor() {
                this.currentSection = 0;
                this.totalSections = 9;
                this.audioEnabled = true;
                this.visualizations = {};
                this.scenes = {};
                this.cameras = {};
                this.renderers = {};
                this.controls = {};
                this.animationStates = {};
                
                this.init();
            }
            
            init() {
                this.showLoading();
                this.setupEventListeners();
                this.initThreeJSScenes();
                this.updateDisplay();
                
                // Simulate loading
                let progress = 0;
                const loadingInterval = setInterval(() => {
                    progress += Math.random() * 15;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(loadingInterval);
                        this.hideLoading();
                    }
                    document.getElementById('loading-progress').style.width = `${progress}%`;
                }, 200);
            }
            
            showLoading() {
                document.getElementById('loading-screen').classList.remove('hidden');
            }
            
            hideLoading() {
                setTimeout(() => {
                    document.getElementById('loading-screen').classList.add('hidden');
                    this.startCurrentVisualization();
                    this.playIntroduction();
                }, 500);
            }
            
            playIntroduction() {
                if (this.audioEnabled) {
                    setTimeout(() => {
                        const introMessage = "Welcome to the Interactive Electrical Concepts Experience! You'll explore nine fundamental topics in electricity and electronics. Use the navigation dots, arrow keys, or scroll wheel to move between sections. Press M to toggle audio narration. Each visualization demonstrates real physics with accurate calculations and measurements. Let's begin your journey into the fascinating world of electricity!";
                        
                        if (window.cartesiaTTS) {
                            window.cartesiaTTS.speak(introMessage);
                        }
                    }, 1000);
                }
            }
            
            initThreeJSScenes() {
                const vizNames = ['charge', 'current', 'resistance', 'voltage', 'ohms', 'components', 'configurations', 'heating', 'power'];
                
                vizNames.forEach(name => {
                    const canvas = document.getElementById(`${name}-canvas`);
                    if (canvas) {
                        const container = canvas.parentElement;
                        
                        // Scene setup
                        const scene = new THREE.Scene();
                        scene.background = new THREE.Color(0x1a1a1a);
                        
                        // Camera setup
                        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                        camera.position.set(0, 0, 5);
                        
                        // Renderer setup
                        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                        renderer.setSize(container.clientWidth, container.clientHeight);
                        renderer.setPixelRatio(window.devicePixelRatio);
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                        
                        // Controls setup
                        const controls = new THREE.OrbitControls(camera, canvas);
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.enableZoom = true;
                        controls.autoRotate = false;
                        controls.autoRotateSpeed = 2.0;
                        
                        // Lighting setup
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                        scene.add(ambientLight);
                        
                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        directionalLight.position.set(10, 10, 5);
                        directionalLight.castShadow = true;
                        directionalLight.shadow.mapSize.width = 2048;
                        directionalLight.shadow.mapSize.height = 2048;
                        scene.add(directionalLight);
                        
                        const pointLight = new THREE.PointLight(0x4a9eff, 0.5, 100);
                        pointLight.position.set(0, 5, 0);
                        scene.add(pointLight);
                        
                        // Store references
                        this.scenes[name] = scene;
                        this.cameras[name] = camera;
                        this.renderers[name] = renderer;
                        this.controls[name] = controls;
                        this.animationStates[name] = { playing: true, time: 0 };
                        
                        // Initialize specific visualization
                        this[`create${name.charAt(0).toUpperCase() + name.slice(1)}Visualization`](scene);
                    }
                });
                
                // Start render loop
                this.animate();
            }
            
            createChargeVisualization(scene) {
                // Create dynamic charge attraction demonstration
                const chargeGroup = new THREE.Group();
                
                // Physical constants for accurate calculations
                const k = 8.99e9; // Coulomb's constant (N⋅m²/C²)
                const elementaryCharge = 1.6e-19; // Elementary charge (C)
                const scale = 1e10; // Scale factor for visualization
                
                // Create charges with realistic properties
                const charges = [];
                
                // POSITIVE CHARGE - Stationary (like a proton in nucleus)
                const positiveChargeGeometry = new THREE.SphereGeometry(0.4, 32, 32);
                const positiveChargeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff3333, 
                    emissive: 0x441111,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.9
                });
                const positiveCharge = new THREE.Mesh(positiveChargeGeometry, positiveChargeMaterial);
                positiveCharge.position.set(0, 0, 0); // Fixed at origin
                positiveCharge.userData = { 
                    charge: +elementaryCharge * 20, // 20 elementary charges
                    type: 'positive',
                    label: '+20e',
                    mass: 1.67e-27 * 20, // 20 proton masses
                    position: new THREE.Vector3(0, 0, 0),
                    fixed: true // This charge doesn't move
                };
                charges.push(positiveCharge);
                chargeGroup.add(positiveCharge);
                
                // NEGATIVE CHARGE - Mobile (electron that gets attracted)
                const negativeChargeGeometry = new THREE.SphereGeometry(0.2, 32, 32);
                const negativeChargeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x3333ff, 
                    emissive: 0x111144,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.9
                });
                const negativeCharge = new THREE.Mesh(negativeChargeGeometry, negativeChargeMaterial);
                
                // Start the negative charge at a random position around the positive charge
                const startAngle = Math.random() * Math.PI * 2;
                const startRadius = 3 + Math.random() * 2; // Random distance 3-5 units away
                negativeCharge.position.set(
                    Math.cos(startAngle) * startRadius,
                    Math.sin(startAngle) * startRadius,
                    (Math.random() - 0.5) * 2
                );
                
                negativeCharge.userData = { 
                    charge: -elementaryCharge * 10, // -10 elementary charges
                    type: 'negative',
                    label: '-10e',
                    mass: 9.11e-31 * 10, // 10 electron masses
                    position: negativeCharge.position.clone(),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02, // Small initial random velocity
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.01
                    ),
                    fixed: false, // This charge moves
                    originalDistance: startRadius,
                    orbitRadius: startRadius,
                    hasBeenCaptured: false
                };
                charges.push(negativeCharge);
                chargeGroup.add(negativeCharge);
                
                // Create charge labels
                const createChargeLabel = (text, position, color) => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 128;
                    context.fillStyle = color;
                    context.font = 'Bold 48px Arial';
                    context.textAlign = 'center';
                    context.fillText(text, 128, 80);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.copy(position);
                    sprite.position.y += 0.6;
                    sprite.scale.set(1, 0.5, 1);
                    return sprite;
                };
                
                const positiveLabel = createChargeLabel('+20e (Fixed)', positiveCharge.position, '#ffffff');
                const negativeLabel = createChargeLabel('-10e (Mobile)', negativeCharge.position, '#ffffff');
                chargeGroup.add(positiveLabel);
                chargeGroup.add(negativeLabel);
                
                // Create dynamic electric field lines that update based on charge positions
                const fieldLines = [];
                const numFieldLines = 20;
                
                for (let i = 0; i < numFieldLines; i++) {
                    const angle = (i / numFieldLines) * Math.PI * 2;
                    const fieldGeometry = new THREE.BufferGeometry();
                    const fieldMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0.6,
                        linewidth: 2
                    });
                    const fieldLine = new THREE.Line(fieldGeometry, fieldMaterial);
                    fieldLine.userData = { 
                        angle: angle,
                        points: [],
                        startRadius: 0.4 // Start from positive charge surface
                    };
                    fieldLines.push(fieldLine);
                    chargeGroup.add(fieldLine);
                }
                
                // Create force visualization arrow on the negative charge
                const forceArrowGeometry = new THREE.ConeGeometry(0.1, 0.6, 8);
                const forceArrowMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
                const forceArrow = new THREE.Mesh(forceArrowGeometry, forceArrowMaterial);
                forceArrow.userData = { type: 'attractive' };
                chargeGroup.add(forceArrow);
                
                // Create velocity vector arrow on the negative charge
                const velocityArrowGeometry = new THREE.ConeGeometry(0.08, 0.4, 8);
                const velocityArrowMaterial = new THREE.MeshPhongMaterial({ color: 0xff6600 });
                const velocityArrow = new THREE.Mesh(velocityArrowGeometry, velocityArrowMaterial);
                velocityArrow.userData = { type: 'velocity' };
                chargeGroup.add(velocityArrow);
                
                // Create trail effect for the negative charge
                const trailGeometry = new THREE.BufferGeometry();
                const trailMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x6666ff,
                    transparent: true,
                    opacity: 0.5,
                    linewidth: 3
                });
                const trail = new THREE.Line(trailGeometry, trailMaterial);
                const trailPoints = [];
                chargeGroup.add(trail);
                
                // Create equipotential surfaces around the positive charge
                const equipotentialSurfaces = [];
                const potentialLevels = [1, 2, 3, 5, 8]; // Different potential levels
                
                potentialLevels.forEach((level, index) => {
                    const surfaceGeometry = new THREE.RingGeometry(level * 0.8, level * 0.8 + 0.05, 64);
                    const surfaceMaterial = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(0.15 + index * 0.1, 0.8, 0.5),
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
                    surface.rotation.x = Math.PI / 2;
                    equipotentialSurfaces.push(surface);
                    chargeGroup.add(surface);
                });
                
                // Create measurement displays
                const createInfoDisplay = (text, position, color = '#00ffff') => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 600;
                    canvas.height = 80;
                    context.fillStyle = color;
                    context.font = 'Bold 22px Arial';
                    context.textAlign = 'center';
                    context.fillText(text, 300, 50);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.copy(position);
                    sprite.scale.set(3, 0.6, 1);
                    return sprite;
                };
                
                const distanceDisplay = createInfoDisplay('Distance: calculating...', new THREE.Vector3(0, -3, 0));
                const forceDisplay = createInfoDisplay('Force: calculating...', new THREE.Vector3(0, -3.8, 0));
                const velocityDisplay = createInfoDisplay('Velocity: calculating...', new THREE.Vector3(0, -4.6, 0));
                const energyDisplay = createInfoDisplay('Kinetic Energy: calculating...', new THREE.Vector3(0, -5.4, 0));
                
                chargeGroup.add(distanceDisplay);
                chargeGroup.add(forceDisplay);
                chargeGroup.add(velocityDisplay);
                chargeGroup.add(energyDisplay);
                
                // Create orbital path indicator
                const orbitGeometry = new THREE.RingGeometry(1.5, 1.52, 64);
                const orbitMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const orbitIndicator = new THREE.Mesh(orbitGeometry, orbitMaterial);
                orbitIndicator.rotation.x = Math.PI / 2;
                chargeGroup.add(orbitIndicator);
                
                scene.add(chargeGroup);
                
                scene.userData = { 
                    chargeGroup,
                    charges, 
                    fieldLines,
                    equipotentialSurfaces,
                    forceArrow,
                    velocityArrow,
                    trail,
                    trailPoints,
                    orbitIndicator,
                    positiveLabel,
                    negativeLabel,
                    displays: {
                        distance: distanceDisplay,
                        force: forceDisplay,
                        velocity: velocityDisplay,
                        energy: energyDisplay
                    },
                    time: 0,
                    k: k,
                    elementaryCharge: elementaryCharge,
                    scale: scale,
                    resetTimer: 0
                };
            }
            
            createCurrentVisualization(scene) {
                // Create realistic electron drift demonstration
                const currentGroup = new THREE.Group();
                
                // Physical constants for accurate current modeling
                const electronCharge = 1.6e-19; // C
                const electronMass = 9.11e-31; // kg
                const copperAtomDensity = 8.5e28; // atoms/m³
                const freeElectronsPerAtom = 1;
                const electronDensity = copperAtomDensity * freeElectronsPerAtom; // electrons/m³
                const driftVelocity = 1e-4; // m/s (typical for 1A in copper wire)
                const thermalVelocity = 1e6; // m/s (thermal motion)
                const relaxationTime = 2.7e-14; // s (collision time in copper)
                
                // Create copper conductor wire with realistic properties
                const wireGeometry = new THREE.CylinderGeometry(0.15, 0.15, 8, 32);
                const wireMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xCC6600,
                    metalness: 0.7,
                    roughness: 0.3,
                    shininess: 100
                });
                const wire = new THREE.Mesh(wireGeometry, wireMaterial);
                wire.rotation.z = Math.PI / 2;
                wire.userData = {
                    resistance: 0.02, // ohms
                    crossSectionalArea: Math.PI * 0.15 * 0.15,
                    length: 8,
                    resistivity: 1.7e-8 // ohm⋅m for copper
                };
                currentGroup.add(wire);
                
                // Create copper atoms lattice structure (simplified)
                const copperAtoms = [];
                for (let x = -3.5; x <= 3.5; x += 0.3) {
                    for (let y = -0.1; y <= 0.1; y += 0.1) {
                        for (let z = -0.1; z <= 0.1; z += 0.1) {
                            const atomGeometry = new THREE.SphereGeometry(0.02, 8, 8);
                            const atomMaterial = new THREE.MeshPhongMaterial({ 
                                color: 0xFFAA66,
                                transparent: true,
                                opacity: 0.5
                            });
                            const atom = new THREE.Mesh(atomGeometry, atomMaterial);
                            atom.position.set(x, y, z);
                            atom.userData = {
                                vibrationAmplitude: 0.005,
                                originalPosition: new THREE.Vector3(x, y, z)
                            };
                            copperAtoms.push(atom);
                            currentGroup.add(atom);
                        }
                    }
                }
                
                // Create realistic electron population
                const electrons = [];
                const numElectrons = 100; // Scaled down for visualization
                
                for (let i = 0; i < numElectrons; i++) {
                    const electronGeometry = new THREE.SphereGeometry(0.025, 12, 12);
                    const electronMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x4a9eff,
                        emissive: 0x001144,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const electron = new THREE.Mesh(electronGeometry, electronMaterial);
                    electron.position.set(
                        -4 + Math.random() * 8,
                        (Math.random() - 0.5) * 0.25,
                        (Math.random() - 0.5) * 0.25
                    );
                    
                    // Realistic electron properties
                    electron.userData = {
                        // Thermal velocity (random motion)
                        thermalVelocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1
                        ),
                        // Drift velocity (net motion due to electric field)
                        driftVelocity: new THREE.Vector3(0.002, 0, 0), // Much slower than thermal
                        position: electron.position.clone(),
                        lastCollisionTime: 0,
                        meanFreePath: driftVelocity * relaxationTime,
                        energy: 0.5 * electronMass * thermalVelocity * thermalVelocity,
                        scatteringEvents: 0
                    };
                    
                    electrons.push(electron);
                    currentGroup.add(electron);
                }
                
                // Current direction and field indicators
                const fieldArrowGeometry = new THREE.ConeGeometry(0.08, 0.3, 8);
                const fieldArrowMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444 });
                
                // Electric field direction (opposite to electron motion)
                const electricFieldArrow = new THREE.Mesh(fieldArrowGeometry, fieldArrowMaterial);
                electricFieldArrow.position.set(0, 0.5, 0);
                electricFieldArrow.rotation.z = -Math.PI / 2;
                currentGroup.add(electricFieldArrow);
                
                // Conventional current direction
                const currentArrow = new THREE.Mesh(fieldArrowGeometry, new THREE.MeshPhongMaterial({ color: 0x00ff00 }));
                currentArrow.position.set(0, 0.7, 0);
                currentArrow.rotation.z = -Math.PI / 2;
                currentGroup.add(currentArrow);
                
                // Voltage source (battery)
                const batteryGeometry = new THREE.BoxGeometry(0.4, 0.8, 0.3);
                const batteryMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const battery = new THREE.Mesh(batteryGeometry, batteryMaterial);
                battery.position.set(-5, 0, 0);
                currentGroup.add(battery);
                
                // Battery terminals
                const positiveTerminal = new THREE.Mesh(
                    new THREE.BoxGeometry(0.42, 0.1, 0.32),
                    new THREE.MeshPhongMaterial({ color: 0xff4444 })
                );
                positiveTerminal.position.set(-5, 0.45, 0);
                currentGroup.add(positiveTerminal);
                
                const negativeTerminal = new THREE.Mesh(
                    new THREE.BoxGeometry(0.42, 0.1, 0.32),
                    new THREE.MeshPhongMaterial({ color: 0x4444ff })
                );
                negativeTerminal.position.set(-5, -0.45, 0);
                currentGroup.add(negativeTerminal);
                
                // Ammeter for current measurement
                const ammeterGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16);
                const ammeterMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
                const ammeter = new THREE.Mesh(ammeterGeometry, ammeterMaterial);
                ammeter.position.set(2, 0, 0);
                ammeter.rotation.x = Math.PI / 2;
                currentGroup.add(ammeter);
                
                // Ammeter display
                const displayGeometry = new THREE.CircleGeometry(0.25, 32);
                const displayMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x001100,
                    emissive: 0x004400
                });
                const display = new THREE.Mesh(displayGeometry, displayMaterial);
                display.position.set(2, 0.06, 0);
                display.rotation.x = Math.PI / 2;
                currentGroup.add(display);
                
                // Current calculation and display
                const current = electronDensity * electronCharge * wire.userData.crossSectionalArea * driftVelocity;
                
                const createInfoDisplay = (text, position) => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 64;
                    context.fillStyle = '#00ffff';
                    context.font = 'Bold 20px Arial';
                    context.textAlign = 'center';
                    context.fillText(text, 256, 40);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.copy(position);
                    sprite.scale.set(2, 0.5, 1);
                    return sprite;
                };
                
                const currentDisplay = createInfoDisplay(`Current: ${current.toExponential(2)} A`, new THREE.Vector3(0, -1.2, 0));
                const driftVelDisplay = createInfoDisplay(`Drift Velocity: ${driftVelocity.toExponential(2)} m/s`, new THREE.Vector3(0, -1.7, 0));
                const thermalVelDisplay = createInfoDisplay(`Thermal Velocity: ${thermalVelocity.toExponential(2)} m/s`, new THREE.Vector3(0, -2.2, 0));
                
                currentGroup.add(currentDisplay);
                currentGroup.add(driftVelDisplay);
                currentGroup.add(thermalVelDisplay);
                
                // Collision visualization particles
                const collisionEffects = [];
                
                scene.add(currentGroup);
                
                scene.userData = { 
                    currentGroup,
                    wire, 
                    electrons, 
                    copperAtoms,
                    electricFieldArrow,
                    currentArrow,
                    ammeter,
                    display,
                    collisionEffects,
                    driftVelocity,
                    thermalVelocity,
                    relaxationTime,
                    currentValue: current
                };
            }
            
            createResistanceVisualization(scene) {
                // Create realistic resistance demonstration with material physics
                const resistanceGroup = new THREE.Group();
                
                // Material properties for different resistor types
                const materials = {
                    carbon: { resistivity: 3e-5, tempCoeff: -0.0005, color: 0x333333 },
                    nichrome: { resistivity: 1e-6, tempCoeff: 0.0004, color: 0x888888 },
                    copper: { resistivity: 1.7e-8, tempCoeff: 0.0039, color: 0xCC6600 }
                };
                
                // Create resistor with realistic dimensions
                const resistorLength = 2.0; // meters
                const resistorRadius = 0.15; // meters
                const crossSectionalArea = Math.PI * resistorRadius * resistorRadius;
                
                // Main resistor body (carbon composition)
                const resistorGeometry = new THREE.CylinderGeometry(resistorRadius, resistorRadius, resistorLength, 32);
                const resistorMaterial = new THREE.MeshPhongMaterial({ 
                    color: materials.carbon.color,
                    roughness: 0.8,
                    metalness: 0.1
                });
                const resistor = new THREE.Mesh(resistorGeometry, resistorMaterial);
                resistor.rotation.z = Math.PI / 2;
                resistor.userData = {
                    material: 'carbon',
                    baseResistance: materials.carbon.resistivity * resistorLength / crossSectionalArea,
                    temperature: 293, // 20°C in Kelvin
                    current: 0,
                    power: 0,
                    heatCapacity: 700 // J/(kg⋅K)
                };
                resistanceGroup.add(resistor);
                
                // Color bands for resistance value (1kΩ = brown-black-red-gold)
                const bandData = [
                    { color: 0x8B4513, position: -0.6, value: 1 }, // Brown (1)
                    { color: 0x000000, position: -0.2, value: 0 }, // Black (0)
                    { color: 0xFF0000, position: 0.2, value: 100 }, // Red (×100)
                    { color: 0xFFD700, position: 0.6, tolerance: 5 } // Gold (±5%)
                ];
                
                bandData.forEach((band, index) => {
                    const bandGeometry = new THREE.CylinderGeometry(resistorRadius + 0.01, resistorRadius + 0.01, 0.15, 16);
                    const bandMaterial = new THREE.MeshPhongMaterial({ color: band.color });
                    const bandMesh = new THREE.Mesh(bandGeometry, bandMaterial);
                    bandMesh.position.set(band.position, 0, 0);
                    bandMesh.rotation.z = Math.PI / 2;
                    resistanceGroup.add(bandMesh);
                });
                
                // Wire leads with realistic gauge
                const wireRadius = 0.02;
                const leftWireGeometry = new THREE.CylinderGeometry(wireRadius, wireRadius, 1.5, 16);
                const rightWireGeometry = new THREE.CylinderGeometry(wireRadius, wireRadius, 1.5, 16);
                const wireMaterial = new THREE.MeshPhongMaterial({ 
                    color: materials.copper.color,
                    metalness: 0.8,
                    roughness: 0.2
                });
                
                const leftWire = new THREE.Mesh(leftWireGeometry, wireMaterial);
                leftWire.position.set(-1.75, 0, 0);
                leftWire.rotation.z = Math.PI / 2;
                leftWire.userData = { resistance: materials.copper.resistivity * 1.5 / (Math.PI * wireRadius * wireRadius) };
                resistanceGroup.add(leftWire);
                
                const rightWire = new THREE.Mesh(rightWireGeometry, wireMaterial);
                rightWire.position.set(1.75, 0, 0);
                rightWire.rotation.z = Math.PI / 2;
                rightWire.userData = { resistance: materials.copper.resistivity * 1.5 / (Math.PI * wireRadius * wireRadius) };
                resistanceGroup.add(rightWire);
                
                // Create atomic lattice structure inside resistor
                const carbonAtoms = [];
                const numAtoms = 200;
                
                for (let i = 0; i < numAtoms; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * (resistorRadius - 0.02);
                    const x = (Math.random() - 0.5) * resistorLength * 0.8;
                    const y = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    const atomGeometry = new THREE.SphereGeometry(0.015, 8, 8);
                    const atomMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x444444,
                        transparent: true,
                        opacity: 0.7
                    });
                    const atom = new THREE.Mesh(atomGeometry, atomMaterial);
                    atom.position.set(x, y, z);
                    atom.userData = {
                        originalPosition: new THREE.Vector3(x, y, z),
                        vibrationAmplitude: 0.003,
                        temperature: 293
                    };
                    carbonAtoms.push(atom);
                    resistanceGroup.add(atom);
                }
                
                // Electron flow with realistic collision physics
                const electrons = [];
                const numElectrons = 40;
                
                for (let i = 0; i < numElectrons; i++) {
                    const electronGeometry = new THREE.SphereGeometry(0.015, 12, 12);
                    const electronMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x4a9eff,
                        emissive: 0x002244
                    });
                    
                    const electron = new THREE.Mesh(electronGeometry, electronMaterial);
                    electron.position.set(
                        -1 + Math.random() * 2,
                        (Math.random() - 0.5) * resistorRadius * 0.8,
                        (Math.random() - 0.5) * resistorRadius * 0.8
                    );
                    
                    electron.userData = {
                        velocity: new THREE.Vector3(0.01 + Math.random() * 0.02, 0, 0),
                        energy: 1 + Math.random(),
                        meanFreePath: 1e-8, // meters
                        collisionCount: 0,
                        lastCollisionTime: 0,
                        scatteringAngle: 0,
                        temperature: 293
                    };
                    
                    electrons.push(electron);
                    resistanceGroup.add(electron);
                }
                
                // Heat generation visualization
                const heatParticles = [];
                for (let i = 0; i < 30; i++) {
                    const heatGeometry = new THREE.SphereGeometry(0.008, 6, 6);
                    const heatMaterial = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(0.08, 1, 0.7),
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const heat = new THREE.Mesh(heatGeometry, heatMaterial);
                    heat.position.set(
                        (Math.random() - 0.5) * resistorLength,
                        (Math.random() - 0.5) * resistorRadius,
                        (Math.random() - 0.5) * resistorRadius
                    );
                    heat.userData = {
                        velocity: new THREE.Vector3(0, Math.random() * 0.005, 0),
                        life: Math.random(),
                        temperature: 293,
                        energy: 0
                    };
                    heatParticles.push(heat);
                    resistanceGroup.add(heat);
                }
                
                // Temperature measurement and displays
                const thermometer = new THREE.Group();
                const thermometerBody = new THREE.CylinderGeometry(0.02, 0.02, 0.8, 8);
                const thermometerMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                const thermometerMesh = new THREE.Mesh(thermometerBody, thermometerMaterial);
                thermometerMesh.position.set(0, 0.5, 0);
                thermometer.add(thermometerMesh);
                
                // Mercury column
                const mercuryGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.1, 8);
                const mercuryMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
                const mercury = new THREE.Mesh(mercuryGeometry, mercuryMaterial);
                mercury.position.set(0, 0.1, 0);
                mercury.userData = { baseHeight: 0.1 };
                thermometer.add(mercury);
                
                thermometer.position.set(0, 0, 0.3);
                resistanceGroup.add(thermometer);
                
                // Voltage and current sources for accurate I²R calculation
                const voltage = 12; // volts
                const resistance = resistor.userData.baseResistance + leftWire.userData.resistance + rightWire.userData.resistance;
                const current = voltage / resistance;
                const power = current * current * resistance; // I²R
                
                // Information displays
                const createTechnicalDisplay = (text, position, color = '#00ffff') => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 400;
                    canvas.height = 50;
                    context.fillStyle = color;
                    context.font = 'Bold 16px Arial';
                    context.textAlign = 'center';
                    context.fillText(text, 200, 30);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.copy(position);
                    sprite.scale.set(1.5, 0.3, 1);
                    return sprite;
                };
                
                const resistanceDisplay = createTechnicalDisplay(`R = ${resistance.toFixed(1)} Ω`, new THREE.Vector3(0, -1, 0));
                const currentDisplay = createTechnicalDisplay(`I = ${current.toFixed(3)} A`, new THREE.Vector3(0, -1.4, 0));
                const powerDisplay = createTechnicalDisplay(`P = I²R = ${power.toFixed(2)} W`, new THREE.Vector3(0, -1.8, 0));
                const tempDisplay = createTechnicalDisplay(`T = 20°C`, new THREE.Vector3(0, -2.2, 0));
                
                resistanceGroup.add(resistanceDisplay);
                resistanceGroup.add(currentDisplay);
                resistanceGroup.add(powerDisplay);
                resistanceGroup.add(tempDisplay);
                
                // Collision visualization effects
                const collisionEffects = [];
                
                // Electric field visualization inside resistor
                const fieldLines = [];
                for (let i = 0; i < 10; i++) {
                    const fieldGeometry = new THREE.BufferGeometry();
                    const fieldPoints = [];
                    for (let j = 0; j < 20; j++) {
                        const x = -1 + j * 0.1;
                        const y = (Math.random() - 0.5) * 0.1;
                        const z = (Math.random() - 0.5) * 0.1;
                        fieldPoints.push(new THREE.Vector3(x, y, z));
                    }
                    fieldGeometry.setFromPoints(fieldPoints);
                    const fieldMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.4
                    });
                    const fieldLine = new THREE.Line(fieldGeometry, fieldMaterial);
                    fieldLines.push(fieldLine);
                    resistanceGroup.add(fieldLine);
                }
                
                scene.add(resistanceGroup);
                
                scene.userData = { 
                    resistanceGroup,
                    resistor, 
                    carbonAtoms,
                    electrons,
                    heatParticles, 
                    thermometer,
                    mercury,
                    collisionEffects,
                    fieldLines,
                    voltage,
                    current,
                    power,
                    resistance,
                    materials,
                    displays: {
                        resistance: resistanceDisplay,
                        current: currentDisplay,
                        power: powerDisplay,
                        temperature: tempDisplay
                    }
                };
            }
            
            createVoltageVisualization(scene) {
                // Create battery
                const batteryGeometry = new THREE.BoxGeometry(0.3, 1, 0.2);
                const batteryMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const battery = new THREE.Mesh(batteryGeometry, batteryMaterial);
                scene.add(battery);
                
                // Battery terminals
                const terminalGeometry = new THREE.BoxGeometry(0.32, 0.1, 0.22);
                const positiveTerminal = new THREE.Mesh(terminalGeometry, new THREE.MeshPhongMaterial({ color: 0xff4444 }));
                positiveTerminal.position.set(0, 0.55, 0);
                scene.add(positiveTerminal);
                
                const negativeTerminal = new THREE.Mesh(terminalGeometry, new THREE.MeshPhongMaterial({ color: 0x4444ff }));
                negativeTerminal.position.set(0, -0.55, 0);
                scene.add(negativeTerminal);
                
                // Electric field visualization
                const fieldLines = [];
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const points = [];
                    
                    for (let j = 0; j < 50; j++) {
                        const radius = 0.5 + j * 0.05;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        const y = Math.sin(j * 0.2) * 0.1;
                        points.push(new THREE.Vector3(x, y, z));
                    }
                    
                    const fieldGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const fieldMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x4a9eff,
                        transparent: true,
                        opacity: 0.6
                    });
                    const fieldLine = new THREE.Line(fieldGeometry, fieldMaterial);
                    fieldLines.push(fieldLine);
                    scene.add(fieldLine);
                }
                
                // Voltage potential mesh
                const potentialGeometry = new THREE.SphereGeometry(2, 32, 32);
                const potentialMaterial = new THREE.ShaderMaterial({
                    vertexShader: `
                        uniform float time;
                        varying vec3 vPosition;
                        void main() {
                            vPosition = position;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        varying vec3 vPosition;
                        void main() {
                            float potential = sin(vPosition.y * 3.0 + time) * 0.5 + 0.5;
                            vec3 color = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), potential);
                            gl_FragColor = vec4(color, 0.3);
                        }
                    `,
                    uniforms: {
                        time: { value: 0 }
                    },
                    transparent: true,
                    side: THREE.BackSide
                });
                
                const fieldMesh = new THREE.Mesh(potentialGeometry, potentialMaterial);
                scene.add(fieldMesh);
                
                scene.userData = { battery, fieldLines, fieldMesh };
            }
            
            createOhmsVisualization(scene) {
                // Create simple circuit
                const circuitGroup = new THREE.Group();
                
                // Battery
                const batteryGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.15);
                const batteryMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const battery = new THREE.Mesh(batteryGeometry, batteryMaterial);
                battery.position.set(-2, 0, 0);
                circuitGroup.add(battery);
                
                // Battery terminals
                const terminalGeometry = new THREE.BoxGeometry(0.32, 0.1, 0.17);
                const positiveTerminal = new THREE.Mesh(terminalGeometry, new THREE.MeshPhongMaterial({ color: 0xff4444 }));
                positiveTerminal.position.set(-2, 0.45, 0);
                circuitGroup.add(positiveTerminal);
                
                const negativeTerminal = new THREE.Mesh(terminalGeometry, new THREE.MeshPhongMaterial({ color: 0x4444ff }));
                negativeTerminal.position.set(-2, -0.45, 0);
                circuitGroup.add(negativeTerminal);
                
                // Resistor positioned ON the circuit path
                const resistorGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.8, 12);
                const resistorMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const resistor = new THREE.Mesh(resistorGeometry, resistorMaterial);
                resistor.position.set(2, 0.8, 0); // Position on top wire
                resistor.rotation.z = Math.PI / 2;
                circuitGroup.add(resistor);
                
                // Resistor color bands
                const bandColors = [0xFFD700, 0xFF0000, 0x00FF00, 0x888888];
                bandColors.forEach((color, index) => {
                    const bandGeometry = new THREE.CylinderGeometry(0.13, 0.13, 0.06, 12);
                    const bandMaterial = new THREE.MeshPhongMaterial({ color });
                    const band = new THREE.Mesh(bandGeometry, bandMaterial);
                    band.position.set(1.5 + index * 0.25, 0.8, 0);
                    band.rotation.z = Math.PI / 2;
                    circuitGroup.add(band);
                });
                
                // Circuit wires - creating a proper rectangular circuit
                const wireRadius = 0.03;
                const wireSegments = [
                    // Top wire (left to resistor)
                    { start: [-1.85, 0.45, 0], end: [1.6, 0.8, 0] },
                    // Top wire (resistor to right)
                    { start: [2.4, 0.8, 0], end: [3, 0.8, 0] },
                    // Right vertical wire
                    { start: [3, 0.8, 0], end: [3, -0.8, 0] },
                    // Bottom wire
                    { start: [3, -0.8, 0], end: [-1.85, -0.45, 0] }
                ];
                
                wireSegments.forEach(segment => {
                    const direction = new THREE.Vector3().subVectors(
                        new THREE.Vector3(...segment.end),
                        new THREE.Vector3(...segment.start)
                    );
                    const length = direction.length();
                    direction.normalize();
                    
                    const wireGeometry = new THREE.CylinderGeometry(wireRadius, wireRadius, length, 8);
                    const wireMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                    const wire = new THREE.Mesh(wireGeometry, wireMaterial);
                    
                    // Position wire at midpoint
                    wire.position.copy(new THREE.Vector3(...segment.start).add(new THREE.Vector3(...segment.end)).multiplyScalar(0.5));
                    
                    // Orient wire along direction
                    const axis = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(axis, direction);
                    wire.setRotationFromQuaternion(quaternion);
                    
                    circuitGroup.add(wire);
                });
                
                // Current flow particles along the actual circuit path
                const currentParticles = [];
                const circuitPath = [
                    new THREE.Vector3(-1.85, 0.45, 0),   // Battery positive
                    new THREE.Vector3(-0.5, 0.65, 0),    // Transition to top
                    new THREE.Vector3(1.6, 0.8, 0),     // Before resistor
                    new THREE.Vector3(2.4, 0.8, 0),     // After resistor
                    new THREE.Vector3(3, 0.8, 0),       // Right top
                    new THREE.Vector3(3, 0, 0),         // Right middle
                    new THREE.Vector3(3, -0.8, 0),      // Right bottom
                    new THREE.Vector3(0, -0.8, 0),      // Bottom middle
                    new THREE.Vector3(-1.85, -0.45, 0)  // Battery negative
                ];
                
                for (let i = 0; i < 12; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.025, 8, 8);
                    const particleMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xffff00,
                        emissive: 0x444400
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.userData = { 
                        t: i / 12,
                        path: circuitPath
                    };
                    currentParticles.push(particle);
                    circuitGroup.add(particle);
                }
                
                // Voltage and current measurement displays
                const voltmeterGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.1);
                const meterMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
                const voltmeter = new THREE.Mesh(voltmeterGeometry, meterMaterial);
                voltmeter.position.set(-2, 1.5, 0);
                circuitGroup.add(voltmeter);
                
                const ammeterGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.1);
                const ammeter = new THREE.Mesh(ammeterGeometry, meterMaterial);
                ammeter.position.set(2, 1.5, 0);
                circuitGroup.add(ammeter);
                
                scene.add(circuitGroup);
                
                // Ohm's law visualization labels with 3D text effect
                const equations = [
                    { text: "V = I × R", position: new THREE.Vector3(0, 2, 0), color: 0x4a9eff },
                    { text: "I = V / R", position: new THREE.Vector3(-3, -1.5, 0), color: 0xff4444 },
                    { text: "R = V / I", position: new THREE.Vector3(3, -1.5, 0), color: 0x00ff88 }
                ];
                
                scene.userData = { circuitGroup, currentParticles, equations, circuitPath };
            }
            
            getPointOnCircuit(t) {
                // Helper method for Ohm's law circuit particle movement
                const points = [
                    new THREE.Vector3(-1.85, 0.45, 0),
                    new THREE.Vector3(-0.5, 0.65, 0),
                    new THREE.Vector3(1.6, 0.8, 0),
                    new THREE.Vector3(2.4, 0.8, 0),
                    new THREE.Vector3(3, 0.8, 0),
                    new THREE.Vector3(3, 0, 0),
                    new THREE.Vector3(3, -0.8, 0),
                    new THREE.Vector3(0, -0.8, 0),
                    new THREE.Vector3(-1.85, -0.45, 0)
                ];
                
                const totalLength = points.length - 1;
                const segmentIndex = Math.floor(t * totalLength);
                const segmentT = (t * totalLength) - segmentIndex;
                
                if (segmentIndex >= totalLength) return points[0];
                
                const startPoint = points[segmentIndex];
                const endPoint = points[segmentIndex + 1];
                
                return new THREE.Vector3().lerpVectors(startPoint, endPoint, segmentT);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                Object.keys(this.scenes).forEach(name => {
                    if (this.animationStates[name]?.playing) {
                        this.animationStates[name].time += 0.016;
                        this.updateVisualization(name);
                        this.controls[name].update();
                        this.renderers[name].render(this.scenes[name], this.cameras[name]);
                    }
                });
            }
            
            updateVisualization(name) {
                const scene = this.scenes[name];
                const time = this.animationStates[name].time;
                
                switch (name) {
                    case 'charge':
                        this.updateChargeAnimation(scene, time);
                        break;
                    case 'current':
                        this.updateCurrentAnimation(scene, time);
                        break;
                    case 'resistance':
                        this.updateResistanceAnimation(scene, time);
                        break;
                    case 'voltage':
                        this.updateVoltageAnimation(scene, time);
                        break;
                    case 'ohms':
                        this.updateOhmsAnimation(scene, time);
                        break;
                    default:
                        this.updateGenericAnimation(scene, time);
                }
            }
            
            updateChargeAnimation(scene, time) {
                const { 
                    chargeGroup, 
                    charges, 
                    fieldLines,
                    equipotentialSurfaces,
                    forceArrow,
                    velocityArrow,
                    trail,
                    trailPoints,
                    orbitIndicator,
                    positiveLabel,
                    negativeLabel,
                    displays,
                    k,
                    elementaryCharge,
                    scale
                } = scene.userData;
                
                if (!chargeGroup || !charges || charges.length < 2) return;
                
                // Update time and reset timer
                scene.userData.time = time;
                scene.userData.resetTimer = scene.userData.resetTimer || 0;
                
                const positiveCharge = charges[0]; // Fixed positive charge
                const negativeCharge = charges[1]; // Mobile negative charge
                const deltaTime = 0.016; // 60 FPS
                
                // Calculate distance and relative position
                const distance = positiveCharge.position.distanceTo(negativeCharge.position);
                const relativePos = negativeCharge.position.clone().sub(positiveCharge.position);
                
                // Calculate Coulomb force (attractive)
                const forceMagnitude = k * Math.abs(positiveCharge.userData.charge * negativeCharge.userData.charge) / (distance * distance);
                const forceDirection = relativePos.clone().normalize().multiplyScalar(-1); // Toward positive charge
                const force = forceDirection.clone().multiplyScalar(forceMagnitude);
                
                // Apply force to calculate acceleration (F = ma)
                const acceleration = force.clone().multiplyScalar(1 / negativeCharge.userData.mass);
                
                // Update velocity and position using realistic physics
                negativeCharge.userData.velocity.add(acceleration.multiplyScalar(deltaTime * scale * 1e-15)); // Scale for visualization
                negativeCharge.position.add(negativeCharge.userData.velocity.clone().multiplyScalar(deltaTime * 100)); // Scale for visualization
                
                // Check if charges are too close (collision or capture)
                if (distance < 0.6) {
                    negativeCharge.userData.hasBeenCaptured = true;
                    // Set orbital motion
                    const orbitRadius = 1.5;
                    const orbitSpeed = 0.02;
                    const angle = time * orbitSpeed;
                    negativeCharge.position.set(
                        Math.cos(angle) * orbitRadius,
                        Math.sin(angle) * orbitRadius,
                        Math.sin(time * 0.5) * 0.3 // Small z-oscillation
                    );
                    negativeCharge.userData.velocity.set(
                        -Math.sin(angle) * orbitSpeed * orbitRadius,
                        Math.cos(angle) * orbitSpeed * orbitRadius,
                        0
                    );
                }
                
                // Reset the system if charges get too far apart or after a certain time
                if (distance > 15 || time - scene.userData.resetTimer > 30) {
                    const newAngle = Math.random() * Math.PI * 2;
                    const newRadius = 4 + Math.random() * 2;
                    negativeCharge.position.set(
                        Math.cos(newAngle) * newRadius,
                        Math.sin(newAngle) * newRadius,
                        (Math.random() - 0.5) * 2
                    );
                    negativeCharge.userData.velocity.set(
                        (Math.random() - 0.5) * 0.01,
                        (Math.random() - 0.5) * 0.01,
                        (Math.random() - 0.5) * 0.005
                    );
                    negativeCharge.userData.hasBeenCaptured = false;
                    scene.userData.resetTimer = time;
                }
                
                // Update charge visual effects
                positiveCharge.scale.setScalar(1 + Math.sin(time * 6) * 0.1);
                positiveCharge.material.emissive.setScalar(0.3 + Math.sin(time * 4) * 0.1);
                
                negativeCharge.scale.setScalar(1 + Math.sin(time * 8) * 0.08);
                const velocityMagnitude = negativeCharge.userData.velocity.length();
                negativeCharge.material.emissive.setScalar(0.2 + velocityMagnitude * 50);
                
                // Update labels to follow charges
                if (positiveLabel) {
                    positiveLabel.position.copy(positiveCharge.position);
                    positiveLabel.position.y += 0.6;
                }
                if (negativeLabel) {
                    negativeLabel.position.copy(negativeCharge.position);
                    negativeLabel.position.y += 0.4;
                }
                
                // Update force arrow
                if (forceArrow) {
                    forceArrow.position.copy(negativeCharge.position);
                    forceArrow.position.add(forceDirection.clone().multiplyScalar(0.5));
                    forceArrow.lookAt(negativeCharge.position.clone().add(forceDirection));
                    
                    // Scale arrow based on force magnitude
                    const forceScale = Math.min(Math.log10(forceMagnitude * scale + 1) * 0.2, 2);
                    forceArrow.scale.setScalar(forceScale);
                    forceArrow.material.emissive.setScalar(forceScale * 0.3);
                }
                
                // Update velocity arrow
                if (velocityArrow && negativeCharge.userData.velocity.length() > 0.001) {
                    velocityArrow.position.copy(negativeCharge.position);
                    velocityArrow.position.add(negativeCharge.userData.velocity.clone().normalize().multiplyScalar(0.3));
                    velocityArrow.lookAt(negativeCharge.position.clone().add(negativeCharge.userData.velocity));
                    
                    const velScale = Math.min(velocityMagnitude * 200, 1.5);
                    velocityArrow.scale.setScalar(velScale);
                    velocityArrow.material.emissive.setScalar(velScale * 0.4);
                } else if (velocityArrow) {
                    velocityArrow.scale.setScalar(0.1);
                }
                
                // Update trail effect
                if (trail && trailPoints) {
                    trailPoints.push(negativeCharge.position.clone());
                    if (trailPoints.length > 50) {
                        trailPoints.shift();
                    }
                    trail.geometry.setFromPoints(trailPoints);
                    trail.geometry.attributes.position.needsUpdate = true;
                }
                
                // Update electric field lines
                fieldLines?.forEach((fieldLine, index) => {
                    const angle = fieldLine.userData.angle;
                    const fieldPoints = [];
                    
                    // Start from positive charge surface
                    let currentPos = new THREE.Vector3(
                        Math.cos(angle) * 0.4,
                        Math.sin(angle) * 0.4,
                        0
                    );
                    
                    // Trace field line from positive to negative charge
                    for (let step = 0; step < 60; step++) {
                        fieldPoints.push(currentPos.clone());
                        
                        // Calculate field direction toward negative charge
                        const toNegative = negativeCharge.position.clone().sub(currentPos);
                        const distToNegative = toNegative.length();
                        
                        if (distToNegative > 0.1) {
                            toNegative.normalize().multiplyScalar(0.15);
                            currentPos.add(toNegative);
                        }
                        
                        // Stop if we're close to negative charge or too far
                        if (distToNegative < 0.3 || currentPos.length() > 8) break;
                    }
                    
                    fieldLine.geometry.setFromPoints(fieldPoints);
                    fieldLine.geometry.attributes.position.needsUpdate = true;
                    
                    // Animate field line intensity
                    const fieldIntensity = 0.4 + 0.3 * Math.sin(time * 3 + index * 0.5);
                    fieldLine.material.opacity = fieldIntensity;
                });
                
                // Update equipotential surfaces
                equipotentialSurfaces?.forEach((surface, index) => {
                    surface.rotation.z = time * 0.1 * (index + 1);
                    const pulse = 1 + Math.sin(time * 2 + index) * 0.1;
                    surface.scale.setScalar(pulse);
                });
                
                // Update orbital indicator
                if (orbitIndicator) {
                    orbitIndicator.material.opacity = negativeCharge.userData.hasBeenCaptured ? 0.6 : 0.3;
                    orbitIndicator.rotation.z = time * 0.5;
                }
                
                // Calculate and update displays
                const kineticEnergy = 0.5 * negativeCharge.userData.mass * velocityMagnitude * velocityMagnitude;
                const potentialEnergy = -k * Math.abs(positiveCharge.userData.charge * negativeCharge.userData.charge) / distance;
                
                const updateDisplay = (display, text) => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 600;
                    canvas.height = 80;
                    context.fillStyle = '#00ffff';
                    context.font = 'Bold 22px Arial';
                    context.textAlign = 'center';
                    context.fillText(text, 300, 50);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    display.material.map = texture;
                    display.material.needsUpdate = true;
                };
                
                if (displays) {
                    updateDisplay(displays.distance, `Distance: ${distance.toFixed(2)} units`);
                    updateDisplay(displays.force, `Force: ${forceMagnitude.toExponential(2)} N`);
                    updateDisplay(displays.velocity, `Velocity: ${velocityMagnitude.toExponential(2)} m/s`);
                    updateDisplay(displays.energy, `KE: ${kineticEnergy.toExponential(2)} J, PE: ${potentialEnergy.toExponential(2)} J`);
                }
                
                // Global animation effects
                const globalPulse = 1 + Math.sin(time * 0.8) * 0.02;
                if (chargeGroup) {
                    chargeGroup.scale.setScalar(globalPulse);
                }
            }
            
            updateCurrentAnimation(scene, time) {
                const { 
                    currentGroup,
                    electrons, 
                    copperAtoms,
                    electricFieldArrow,
                    currentArrow,
                    driftVelocity,
                    thermalVelocity,
                    relaxationTime,
                    collisionEffects
                } = scene.userData;
                
                if (!electrons) return;
                
                // Update copper atom thermal vibrations
                copperAtoms?.forEach(atom => {
                    const userData = atom.userData;
                    const vibration = userData.vibrationAmplitude;
                    
                    // Thermal vibration with temperature dependency
                    const temperature = 293 + Math.sin(time * 0.5) * 20; // 273-313K range
                    const vibrationScale = Math.sqrt(temperature / 293); // Thermal velocity scaling
                    
                    atom.position.x = userData.originalPosition.x + Math.sin(time * 20 + userData.originalPosition.x * 10) * vibration * vibrationScale;
                    atom.position.y = userData.originalPosition.y + Math.cos(time * 25 + userData.originalPosition.y * 15) * vibration * vibrationScale;
                    atom.position.z = userData.originalPosition.z + Math.sin(time * 30 + userData.originalPosition.z * 12) * vibration * vibrationScale;
                    
                    // Color change with temperature
                    const tempHue = 0.1 + (temperature - 273) / 100 * 0.05; // Yellow to orange
                    atom.material.color.setHSL(tempHue, 0.8, 0.6);
                });
                
                // Realistic electron motion simulation
                electrons?.forEach((electron, index) => {
                    const userData = electron.userData;
                    
                    // Update thermal motion (random walk)
                    userData.thermalVelocity.x += (Math.random() - 0.5) * 0.002;
                    userData.thermalVelocity.y += (Math.random() - 0.5) * 0.002;
                    userData.thermalVelocity.z += (Math.random() - 0.5) * 0.002;
                    
                    // Limit thermal velocity magnitude
                    if (userData.thermalVelocity.length() > 0.1) {
                        userData.thermalVelocity.normalize().multiplyScalar(0.1);
                    }
                    
                    // Apply drift velocity (much smaller than thermal)
                    const totalVelocity = userData.thermalVelocity.clone().add(userData.driftVelocity);
                    electron.position.add(totalVelocity);
                    
                    // Check for collisions with atoms
                    let collision = false;
                    copperAtoms.forEach((atom, atomIndex) => {
                        const distance = electron.position.distanceTo(atom.position);
                        if (distance < 0.04) { // Collision threshold
                            collision = true;
                            userData.collisionCount++;
                            userData.lastCollisionTime = time;
                            
                            // Scatter electron in random direction
                            userData.scatteringAngle = Math.random() * Math.PI * 2;
                            userData.thermalVelocity.x = Math.cos(userData.scatteringAngle) * 0.08;
                            userData.thermalVelocity.y = Math.sin(userData.scatteringAngle) * 0.08;
                            userData.thermalVelocity.z = (Math.random() - 0.5) * 0.04;
                            
                            // Energy transfer during collision
                            userData.energy *= 0.95; // Some energy lost to atom
                            
                            // Create collision effect
                            if (collisionEffects && collisionEffects.length < 20) {
                                const collisionEffect = new THREE.Mesh(
                                    new THREE.SphereGeometry(0.02, 8, 8),
                                    new THREE.MeshBasicMaterial({ 
                                        color: 0xffff00,
                                        transparent: true,
                                        opacity: 0.8
                                    })
                                );
                                collisionEffect.position.copy(electron.position);
                                collisionEffect.userData = { life: 0.3, startTime: time };
                                collisionEffects.push(collisionEffect);
                                currentGroup.add(collisionEffect);
                            }
                        }
                    });
                    
                    // Boundary conditions (wrap around wire)
                    if (electron.position.x > 4) {
                        electron.position.x = -4;
                    } else if (electron.position.x < -4) {
                        electron.position.x = 4;
                    }
                    
                    // Keep electrons within wire radius
                    const radialDistance = Math.sqrt(electron.position.y * electron.position.y + electron.position.z * electron.position.z);
                    if (radialDistance > 0.12) {
                        const factor = 0.12 / radialDistance;
                        electron.position.y *= factor;
                        electron.position.z *= factor;
                    }
                    
                    // Visual effects based on electron properties
                    const velocityMagnitude = totalVelocity.length();
                    const energyLevel = userData.energy;
                    
                    // Color based on energy/velocity
                    const hue = 0.6 - velocityMagnitude * 2; // Blue to cyan based on speed
                    electron.material.color.setHSL(Math.max(0.4, hue), 1, 0.7);
                    
                    // Glow effect based on recent collisions
                    const timeSinceCollision = time - userData.lastCollisionTime;
                    const collisionGlow = timeSinceCollision < 0.5 ? (0.5 - timeSinceCollision) * 2 : 0;
                    electron.material.emissive.setScalar(0.1 + collisionGlow * 0.4);
                    
                    // Scale based on energy
                    const scale = 0.8 + energyLevel * 0.4;
                    electron.scale.setScalar(scale);
                });
                
                // Update collision effects
                collisionEffects?.forEach((effect, index) => {
                    effect.userData.life -= 0.016;
                    effect.material.opacity = effect.userData.life / 0.3;
                    effect.scale.setScalar(1 + (0.3 - effect.userData.life) * 3);
                    
                    if (effect.userData.life <= 0) {
                        currentGroup.remove(effect);
                        collisionEffects.splice(index, 1);
                    }
                });
                
                // Animate field indicators
                if (electricFieldArrow) {
                    // Pulsing field strength visualization
                    const fieldStrength = 1 + Math.sin(time * 4) * 0.3;
                    electricFieldArrow.scale.setScalar(fieldStrength);
                    electricFieldArrow.material.emissive.setScalar(fieldStrength * 0.3);
                }
                
                if (currentArrow) {
                    // Current magnitude visualization
                    const currentMagnitude = 1 + Math.sin(time * 3) * 0.2;
                    currentArrow.scale.setScalar(currentMagnitude);
                    currentArrow.material.emissive.setScalar(currentMagnitude * 0.2);
                }
                
                // Calculate and display real-time measurements
                const averageDriftVelocity = electrons.reduce((sum, electron) => {
                    return sum + electron.userData.driftVelocity.x;
                }, 0) / electrons.length;
                
                const averageThermalVelocity = electrons.reduce((sum, electron) => {
                    return sum + electron.userData.thermalVelocity.length();
                }, 0) / electrons.length;
                
                const totalCollisions = electrons.reduce((sum, electron) => {
                    return sum + electron.userData.collisionCount;
                }, 0);
                
                // Update displays (if they exist)
                scene.userData.currentMeasurements = {
                    driftVelocity: averageDriftVelocity,
                    thermalVelocity: averageThermalVelocity,
                    collisionRate: totalCollisions / time,
                    temperature: 293 + Math.sin(time * 0.5) * 20
                };
            }
            
            updateResistanceAnimation(scene, time) {
                const { particles, heatParticles } = scene.userData;
                
                particles?.forEach(particle => {
                    particle.position.x += particle.userData.velocity * 0.02;
                    
                    // Slow down in resistor area (-1 to 1)
                    if (particle.position.x > -1 && particle.position.x < 1) {
                        particle.userData.energy += 0.001;
                        particle.userData.velocity *= 0.98;
                        
                        // Generate heat
                        if (Math.random() < 0.1) {
                            particle.userData.collisionTimer = 0.5;
                        }
                    }
                    
                    // Reset particles
                    if (particle.position.x > 3) {
                        particle.position.x = -3;
                        particle.userData.velocity = Math.random() * 0.5 + 0.3;
                        particle.userData.energy = Math.random();
                    }
                    
                    // Update color based on energy
                    const energy = Math.min(particle.userData.energy, 1);
                    particle.material.color.setHSL(0.6 - energy * 0.6, 1, 0.5);
                });
                
                heatParticles?.forEach(heat => {
                    heat.position.add(heat.userData.velocity);
                    heat.userData.life -= 0.01;
                    
                    if (heat.userData.life <= 0) {
                        heat.position.set(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 0.3,
                            (Math.random() - 0.5) * 0.3
                        );
                        heat.userData.life = 1;
                        heat.userData.velocity.set(0, Math.random() * 0.01, 0);
                    }
                    
                    heat.material.opacity = heat.userData.life * 0.6;
                });
            }
            
            updateVoltageAnimation(scene, time) {
                const { fieldMesh } = scene.userData;
                if (fieldMesh?.material.uniforms) {
                    fieldMesh.material.uniforms.time.value = time;
                }
            }
            
            updateOhmsAnimation(scene, time) {
                const { currentParticles, circuitPath } = scene.userData;
                
                currentParticles?.forEach(particle => {
                    particle.userData.t += 0.008;
                    if (particle.userData.t > 1) particle.userData.t = 0;
                    
                    // Use the actual circuit path for particle movement
                    const pathLength = circuitPath.length - 1;
                    const segmentIndex = Math.floor(particle.userData.t * pathLength);
                    const segmentProgress = (particle.userData.t * pathLength) - segmentIndex;
                    
                    if (segmentIndex < pathLength) {
                        const startPoint = circuitPath[segmentIndex];
                        const endPoint = circuitPath[segmentIndex + 1];
                        particle.position.lerpVectors(startPoint, endPoint, segmentProgress);
                    }
                    
                    // Enhanced particle glow effect
                    particle.material.emissive.setScalar(0.3 + 0.2 * Math.sin(time * 8 + particle.userData.t * Math.PI * 2));
                    
                    // Slight scale animation for energy flow effect
                    const scale = 1 + 0.2 * Math.sin(time * 6 + particle.userData.t * Math.PI * 4);
                    particle.scale.setScalar(scale);
                });
            }
            
            updateGenericAnimation(scene, time) {
                const vizName = Object.keys(this.scenes).find(name => this.scenes[name] === scene);
                
                switch(vizName) {
                    case 'components':
                        this.updateComponentsAnimation(scene, time);
                        break;
                    case 'configurations':
                        this.updateConfigurationsAnimation(scene, time);
                        break;
                    case 'heating':
                        this.updateHeatingAnimation(scene, time);
                        break;
                    case 'power':
                        this.updatePowerAnimation(scene, time);
                        break;
                    default:
                        // Fallback generic animation
                        const { mesh } = scene.userData;
                        if (mesh) {
                            mesh.rotation.y = time * 0.5;
                            mesh.rotation.x = Math.sin(time) * 0.1;
                        }
                }
            }
            
            updateComponentsAnimation(scene, time) {
                const { componentsGroup } = scene.userData;
                if (!componentsGroup) return;
                
                // Animate LED glow
                const ledLens = componentsGroup.children.find(child => 
                    child.material && child.material.color && child.material.color.r > 0.8
                );
                if (ledLens) {
                    const intensity = 0.5 + 0.3 * Math.sin(time * 4);
                    ledLens.material.emissive.setScalar(intensity * 0.5);
                }
                
                // Rotate inductor slightly
                const coilGroup = componentsGroup.children.find(child => child.children && child.children.length > 10);
                if (coilGroup) {
                    coilGroup.rotation.y = time * 0.2;
                }
                
                // Subtle component highlighting
                componentsGroup.children.forEach((component, index) => {
                    if (component.material && component.material.emissive) {
                        const phase = time * 2 + index * Math.PI / 3;
                        const glow = 0.1 + 0.05 * Math.sin(phase);
                        component.material.emissive.setScalar(glow);
                    }
                });
            }
            
            updateConfigurationsAnimation(scene, time) {
                const { 
                    mainGroup,
                    seriesGroup, 
                    parallelGroup, 
                    seriesResistors,
                    parallelResistors,
                    seriesCurrentParticles, 
                    parallelCurrentParticles,
                    labelGroup 
                } = scene.userData;
                
                if (!mainGroup) return;
                
                // Calculate circuit values for educational demonstration
                const batteryVoltage = 12; // Volts
                
                // Series circuit calculations
                if (seriesResistors && seriesCurrentParticles) {
                    // Total resistance in series: R_total = R1 + R2 + R3
                    const seriesResistances = [100, 200, 300]; // Ohms
                    const totalSeriesResistance = seriesResistances.reduce((a, b) => a + b, 0);
                    
                    // Current is same throughout series circuit: I = V/R_total
                    const seriesCurrent = batteryVoltage / totalSeriesResistance; // About 0.02 A
                    
                    // Animate series resistors with heat effect based on power dissipation
                    seriesResistors.forEach((resistor, index) => {
                        const resistance = seriesResistances[index];
                        const power = seriesCurrent * seriesCurrent * resistance; // P = I²R
                        const voltage = seriesCurrent * resistance; // V = IR
                        
                        // Heat effect visualization
                        const heatIntensity = power / 3; // Normalize for visualization
                        const hue = 0.15 - heatIntensity * 0.1; // Shift from yellow to red
                        resistor.material.color.setHSL(hue, 1, 0.5 + heatIntensity * 0.3);
                        resistor.material.emissive.setHSL(hue * 0.5, 1, heatIntensity * 0.2);
                        
                        // Store calculated values for display
                        resistor.userData.current = seriesCurrent;
                        resistor.userData.voltage = voltage;
                        resistor.userData.power = power;
                        
                        // Slight thermal expansion effect
                        const expansion = 1 + heatIntensity * 0.05;
                        resistor.scale.setScalar(expansion);
                    });
                    
                    // Animate series current particles
                    seriesCurrentParticles.forEach(particle => {
                        const userData = particle.userData;
                        
                        // Move along the series path
                        userData.progress += 0.012; // Consistent speed throughout series
                        if (userData.progress > 1) userData.progress = 0;
                        
                        const pathLength = userData.path.length - 1;
                        const segmentIndex = Math.floor(userData.progress * pathLength);
                        const segmentProgress = (userData.progress * pathLength) - segmentIndex;
                        
                        if (segmentIndex < pathLength) {
                            const startPoint = userData.path[segmentIndex];
                            const endPoint = userData.path[segmentIndex + 1];
                            particle.position.lerpVectors(startPoint, endPoint, segmentProgress);
                        }
                        
                        // Same current throughout - consistent glow
                        const intensity = 0.6 + 0.4 * Math.sin(time * 8 + userData.progress * Math.PI * 2);
                        particle.material.emissive.setScalar(intensity * 0.4);
                        
                        // Scale based on current magnitude
                        const scale = 0.8 + seriesCurrent * 20; // Amplify for visibility
                        particle.scale.setScalar(scale);
                    });
                }
                
                // Parallel circuit calculations
                if (parallelResistors && parallelCurrentParticles) {
                    const parallelResistance = 300; // All resistors are 300Ω
                    
                    // In parallel: 1/R_total = 1/R1 + 1/R2 + 1/R3
                    const totalParallelResistance = parallelResistance / 3; // 100Ω equivalent
                    
                    // Total current from battery
                    const totalParallelCurrent = batteryVoltage / totalParallelResistance; // 0.12 A
                    
                    // Current divides equally among identical parallel resistors
                    const branchCurrent = totalParallelCurrent / 3; // 0.04 A per branch
                    
                    // Voltage is same across all parallel branches
                    const parallelVoltage = batteryVoltage; // 12V across each resistor
                    
                    // Animate parallel resistors
                    parallelResistors.forEach((resistor, index) => {
                        const power = branchCurrent * branchCurrent * parallelResistance; // P = I²R
                        
                        // Heat effect (less than series since current is divided)
                        const heatIntensity = power / 5; // Lower intensity than series
                        const hue = 0.15 - heatIntensity * 0.08;
                        resistor.material.color.setHSL(hue, 1, 0.5 + heatIntensity * 0.2);
                        resistor.material.emissive.setHSL(hue * 0.5, 1, heatIntensity * 0.15);
                        
                        // Store values
                        resistor.userData.current = branchCurrent;
                        resistor.userData.voltage = parallelVoltage;
                        resistor.userData.power = power;
                        
                        // Thermal expansion
                        const expansion = 1 + heatIntensity * 0.03;
                        resistor.scale.setScalar(expansion);
                    });
                    
                    // Animate parallel current particles (different for each branch)
                    parallelCurrentParticles.forEach(particle => {
                        const userData = particle.userData;
                        
                        // Different speeds to show current division
                        const branchSpeed = 0.015 + userData.branch * 0.002; // Slightly different speeds for visual effect
                        userData.progress += branchSpeed;
                        if (userData.progress > 1) userData.progress = 0;
                        
                        const pathLength = userData.path.length - 1;
                        const segmentIndex = Math.floor(userData.progress * pathLength);
                        const segmentProgress = (userData.progress * pathLength) - segmentIndex;
                        
                        if (segmentIndex < pathLength) {
                            const startPoint = userData.path[segmentIndex];
                            const endPoint = userData.path[segmentIndex + 1];
                            particle.position.lerpVectors(startPoint, endPoint, segmentProgress);
                        }
                        
                        // Branch-specific effects
                        const intensity = 0.5 + 0.3 * Math.sin(time * 6 + userData.progress * Math.PI * 2 + userData.branch);
                        particle.material.emissive.setScalar(intensity * 0.3);
                        
                        // Scale based on branch current
                        const scale = 0.7 + branchCurrent * 15;
                        particle.scale.setScalar(scale);
                    });
                }
                
                // Animate measurement meters with realistic readings
                if (seriesGroup) {
                    // Find voltage meters and update their displays
                    seriesGroup.children.forEach(child => {
                        if (child.userData && child.userData.type === 'voltmeter') {
                            const resistorIndex = child.userData.resistorIndex;
                            if (seriesResistors && seriesResistors[resistorIndex]) {
                                const voltage = seriesResistors[resistorIndex].userData.voltage;
                                
                                // Animate meter display based on voltage reading
                                const intensity = Math.min(voltage / 12, 1); // Normalize to 0-1
                                const meterGlow = 0.2 + intensity * 0.6;
                                
                                // Find the display child
                                seriesGroup.children.forEach(display => {
                                    if (display.position.x === child.position.x && 
                                        display.position.y === child.position.y && 
                                        display.position.z > child.position.z) {
                                        // Add null checks for material properties
                                        if (display.material && display.material.emissive && display.material.emissive.setScalar) {
                                            display.material.emissive.setScalar(meterGlow);
                                        }
                                        
                                        // Color based on voltage level
                                        const hue = 0.4 - intensity * 0.2; // Green to yellow
                                        if (display.material && display.material.color && display.material.color.setHSL) {
                                            display.material.color.setHSL(hue, 1, 0.3 + intensity * 0.4);
                                        }
                                    }
                                });
                            }
                        }
                    });
                }
                
                // Animate educational labels
                if (labelGroup) {
                    labelGroup.children.forEach((label, index) => {
                        // Gentle pulsing for educational emphasis
                        const pulse = 1 + Math.sin(time * 2 + index) * 0.05;
                        label.scale.setScalar(pulse);
                        
                        // Subtle color animation
                        const colorShift = Math.sin(time + index * Math.PI) * 0.1;
                        if (label.material && label.material.color && label.material.opacity !== undefined) {
                            label.material.opacity = 0.8 + colorShift * 0.2;
                        }
                    });
                }
                
                // Educational comparison effects
                const comparisonPhase = Math.sin(time * 0.5) * 0.5 + 0.5;
                
                // Highlight series vs parallel differences
                if (seriesGroup && parallelGroup) {
                    // Emphasize the circuits alternately for comparison
                    const seriesEmphasis = 1 + comparisonPhase * 0.1;
                    const parallelEmphasis = 1 + (1 - comparisonPhase) * 0.1;
                    
                    seriesGroup.scale.setScalar(seriesEmphasis);
                    parallelGroup.scale.setScalar(parallelEmphasis);
                    
                    // Educational information updates
                    if (time % 10 < 5) {
                        // First 5 seconds: highlight series properties
                        seriesGroup.children.forEach(child => {
                            if (child.material && child.material.emissive && child.material.emissive.multiplyScalar) {
                                const boost = Math.sin(time * 4) * 0.1;
                                child.material.emissive.multiplyScalar(1 + boost);
                            }
                        });
                    } else {
                        // Next 5 seconds: highlight parallel properties
                        parallelGroup.children.forEach(child => {
                            if (child.material && child.material.emissive && child.material.emissive.multiplyScalar) {
                                const boost = Math.sin(time * 4) * 0.1;
                                child.material.emissive.multiplyScalar(1 + boost);
                            }
                        });
                    }
                }
                
                // Add circuit formula visualization
                const formulaPhase = Math.floor(time / 5) % 4;
                
                // Visual emphasis on different circuit laws
                if (formulaPhase === 0) {
                    // Emphasize Ohm's Law: V = IR
                } else if (formulaPhase === 1) {
                    // Emphasize Series: R_total = R1 + R2 + R3
                } else if (formulaPhase === 2) {
                    // Emphasize Parallel: 1/R_total = 1/R1 + 1/R2 + 1/R3
                } else {
                    // Emphasize Power: P = VI = I²R
                }
            }
            
            updateHeatingAnimation(scene, time) {
                const { heatingGroup, mainCoilGroup, heatParticles, smokeParticles, sparkParticles, radiationLayers, infraredPlane } = scene.userData;
                
                // Animate main heating coil temperature with more complex patterns
                if (mainCoilGroup) {
                    mainCoilGroup.children.forEach(segment => {
                        const baseTemp = segment.userData.baseTemperature;
                        const segmentIndex = segment.userData.segmentIndex;
                        
                        // Multiple temperature variation patterns
                        const primaryWave = Math.sin(time * 2 + segmentIndex * 0.1) * 0.2;
                        const secondaryWave = Math.sin(time * 3.5 + segmentIndex * 0.05) * 0.1;
                        const randomFlicker = Math.sin(time * 15 + segmentIndex * 0.8) * 0.05;
                        
                        const temp = Math.min(baseTemp + primaryWave + secondaryWave + randomFlicker, segment.userData.maxTemp);
                        
                        const hue = Math.max(0, 0.12 - temp * 0.12);
                        const saturation = 1;
                        const lightness = 0.2 + temp * 0.6;
                        
                        segment.material.color.setHSL(hue, saturation, lightness);
                        segment.material.emissive.setHSL(hue * 0.7, saturation, temp * 0.4);
                        
                        // Slight expansion from heat
                        const expansion = 1 + temp * 0.02;
                        segment.scale.setScalar(expansion);
                    });
                }
                
                // Animate secondary heating strips
                if (heatingGroup) {
                    heatingGroup.children.forEach((stripGroup, stripIndex) => {
                        if (stripIndex > 0) { // Skip main coil group
                            stripGroup.children.forEach(segment => {
                                if (segment.userData.strip !== undefined) {
                                    const baseTemp = segment.userData.baseTemperature;
                                    const segmentIndex = segment.userData.segmentIndex;
                                    const stripPhase = segment.userData.strip * Math.PI / 2;
                                    
                                    const temp = baseTemp + Math.sin(time * 2.5 + stripPhase + segmentIndex * 0.2) * 0.15;
                                    
                                    const hue = 0.1 - temp * 0.1;
                                    segment.material.color.setHSL(hue, 1, 0.3 + temp * 0.5);
                                    segment.material.emissive.setHSL(hue * 0.5, 1, temp * 0.3);
                                }
                            });
                        }
                    });
                }
                
                // Enhanced heat particle animation
                heatParticles?.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.userData.life -= 0.003;
                    
                    // Add turbulence and convection effects
                    const turbulence = Math.sin(time * 4 + particle.position.y * 8) * 0.008;
                    particle.position.x += turbulence;
                    particle.position.z += Math.cos(time * 3 + particle.position.x * 6) * 0.006;
                    
                    // Rotation for more dynamic effect
                    particle.rotation.z += particle.userData.rotationSpeed;
                    
                    if (particle.userData.life <= 0 || particle.position.y > 3) {
                        // Reset particle with slight randomization
                        particle.position.set(
                            (Math.random() - 0.5) * 3,
                            particle.userData.initialY + (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 3
                        );
                        particle.userData.life = 0.8 + Math.random() * 0.4;
                        particle.userData.velocity.set(
                            (Math.random() - 0.5) * 0.02,
                            0.03 + Math.random() * 0.04,
                            (Math.random() - 0.5) * 0.02
                        );
                    }
                    
                    // Dynamic appearance with null checks
                    const life = particle.userData.life;
                    if (particle.material && particle.material.opacity !== undefined) {
                        particle.material.opacity = life * 0.8;
                    }
                    particle.scale.setScalar(1 + (1 - life) * 1.5);
                    
                    // Color shift from red to yellow as they cool
                    const hue = 0.08 + (1 - life) * 0.04;
                    if (particle.material && particle.material.color && particle.material.color.setHSL) {
                        particle.material.color.setHSL(hue, 1, 0.7 + life * 0.3);
                    }
                });
                
                // Smoke particle animation
                smokeParticles?.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.userData.life -= 0.004;
                    
                    // Smoke dispersion and expansion
                    const expansion = particle.userData.expansionRate * (1 - particle.userData.life) * 0.02;
                    particle.scale.setScalar(1 + expansion);
                    
                    // Wind effect
                    particle.position.x += Math.sin(time * 1.5 + particle.position.y * 2) * 0.01;
                    
                    if (particle.userData.life <= 0 || particle.position.y > 2.5) {
                        particle.position.set(
                            (Math.random() - 0.5) * 2,
                            particle.userData.initialY,
                            (Math.random() - 0.5) * 2
                        );
                        particle.userData.life = 1;
                        particle.scale.setScalar(1);
                    }
                    
                    if (particle.material && particle.material.opacity !== undefined) {
                        particle.material.opacity = particle.userData.life * 0.4;
                    }
                });
                
                // Spark particle animation
                sparkParticles?.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.userData.life -= 0.02;
                    
                    // Spark physics - gravity and air resistance
                    particle.userData.velocity.y -= 0.001; // Gravity
                    particle.userData.velocity.multiplyScalar(0.98); // Air resistance
                    
                    if (particle.userData.life <= 0) {
                        // Reset spark
                        particle.position.set(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2
                        );
                        particle.userData.velocity.set(
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.05
                        );
                        particle.userData.life = particle.userData.initialLife;
                    }
                    
                    // Flickering intensity with null checks
                    const intensity = particle.userData.life * (0.8 + 0.4 * Math.sin(time * 20));
                    if (particle.material && particle.material.emissive && particle.material.emissive.setScalar) {
                        particle.material.emissive.setScalar(intensity * 0.6);
                    }
                    if (particle.material && particle.material.opacity !== undefined) {
                        particle.material.opacity = intensity;
                    }
                });
                
                // Animate thermal radiation layers
                radiationLayers?.forEach((layer, index) => {
                    if (layer.material.uniforms) {
                        layer.material.uniforms.time.value = time;
                        
                        // Different rotation speeds for each layer
                        layer.rotation.y = time * (0.1 + index * 0.05);
                        layer.rotation.x = Math.sin(time * 0.5) * 0.1;
                    }
                });
                
                // Animate infrared visualization
                if (infraredPlane?.material.uniforms) {
                    infraredPlane.material.uniforms.time.value = time;
                }
            }
            
            updatePowerAnimation(scene, time) {
                const { powerSystemGroup, powerPlantGroup, rotorGroup, loadGroup, powerParticles, electricArcs } = scene.userData;
                
                // Rotate turbine rotor with realistic speed
                if (rotorGroup) {
                    rotorGroup.rotation.z = time * 3; // Faster rotation for turbine
                    
                    // Subtle vibration effect
                    rotorGroup.position.x = -4 + Math.sin(time * 30) * 0.002;
                    rotorGroup.position.y = Math.cos(time * 25) * 0.002;
                }
                
                // Animate power plant components
                if (powerPlantGroup) {
                    // Steam particles from cooling towers
                    powerPlantGroup.children.forEach(child => {
                        if (child.userData && child.userData.tower !== undefined) {
                            child.position.add(child.userData.velocity);
                            child.userData.life -= 0.01;
                            
                            // Wind effect on steam
                            child.position.x += Math.sin(time * 2 + child.userData.tower * Math.PI) * 0.005;
                            child.position.z += Math.cos(time * 1.5) * 0.003;
                            
                            // Steam expansion
                            const expansion = 1 + (1 - child.userData.life) * 2;
                            child.scale.setScalar(expansion);
                            
                            if (child.userData.life <= 0 || child.position.y > 4) {
                                child.position.set(
                                    -4.5 + child.userData.tower * 1 + (Math.random() - 0.5) * 0.4,
                                    child.userData.initialY,
                                    -1.5 + (Math.random() - 0.5) * 0.4
                                );
                                child.userData.life = 1;
                                child.scale.setScalar(1);
                            }
                            
                            if (child.material && child.material.opacity !== undefined) {
                                child.material.opacity = child.userData.life * 0.6;
                            }
                        }
                    });
                    
                    // Power plant building glow effect
                    const buildingGlow = 0.1 + 0.05 * Math.sin(time * 4);
                    if (powerPlantGroup.children[0] && powerPlantGroup.children[0].material && powerPlantGroup.children[0].material.emissive) {
                        powerPlantGroup.children[0].material.emissive.setScalar(buildingGlow);
                    }
                }
                
                // Enhanced power flow animation
                powerParticles?.forEach(particle => {
                    const userData = particle.userData;
                    userData.progress += userData.speed;
                    
                    if (userData.progress > 1) {
                        userData.progress = 0;
                    }
                    
                    // Enhanced movement along transmission lines with realistic physics
                    const baseX = -1 + userData.progress * 4;
                    const baseY = 2.5 - userData.line * 0.4;
                    
                    // Add realistic cable sag effect to particle movement
                    const sag = Math.sin(userData.progress * Math.PI) * 0.2;
                    
                    // Add electrical field fluctuations
                    const fieldFluctuation = Math.sin(time * userData.frequency + userData.progress * Math.PI * 4) * userData.amplitude;
                    
                    particle.position.set(
                        baseX + fieldFluctuation * 0.5,
                        baseY - sag + fieldFluctuation,
                        fieldFluctuation * 0.3
                    );
                    
                    // Dynamic particle effects
                    const intensity = 0.6 + 0.4 * Math.sin(time * 12 + userData.progress * Math.PI * 6);
                    if (particle.material && particle.material.emissive && particle.material.emissive.setScalar) {
                        particle.material.emissive.setScalar(intensity * 0.5);
                    }
                    
                    // Scale variation for energy flow representation
                    const scale = 0.8 + intensity * 0.4;
                    particle.scale.setScalar(scale);
                    
                    // Add electrical arcing between particles occasionally
                    if (Math.random() < 0.002) {
                        if (particle.material && particle.material.emissive && particle.material.emissive.setScalar) {
                            particle.material.emissive.setScalar(1);
                            setTimeout(() => {
                                if (particle.material && particle.material.emissive && particle.material.emissive.setScalar) {
                                    particle.material.emissive.setScalar(intensity * 0.5);
                                }
                            }, 100);
                        }
                    }
                });
                
                // Electrical arcing effects at substations
                electricArcs?.forEach(arc => {
                    arc.userData.life -= 0.02;
                    
                    if (arc.userData.life <= 0) {
                        arc.userData.life = Math.random();
                        arc.position.set(
                            4 + (Math.random() - 0.5) * 2,
                            1 + Math.random() * 1.5,
                            (Math.random() - 0.5) * 2
                        );
                        arc.userData.intensity = Math.random();
                    }
                    
                    // Flickering arc effect
                    const flicker = Math.sin(time * arc.userData.flickerSpeed) * 0.5 + 0.5;
                    const arcIntensity = arc.userData.intensity * flicker * arc.userData.life;
                    
                    if (arc.material && arc.material.emissive && arc.material.emissive.setScalar) {
                        arc.material.emissive.setScalar(arcIntensity);
                    }
                    if (arc.material && arc.material.opacity !== undefined) {
                        arc.material.opacity = arcIntensity;
                    }
                    arc.scale.setScalar(0.5 + arcIntensity * 2);
                    
                    // Random position jitter for electrical instability
                    if (Math.random() < 0.1) {
                        arc.position.x += (Math.random() - 0.5) * 0.1;
                        arc.position.y += (Math.random() - 0.5) * 0.1;
                        arc.position.z += (Math.random() - 0.5) * 0.1;
                    }
                });
                
                // Animate load consumption (houses and industry)
                if (loadGroup) {
                    loadGroup.children.forEach(load => {
                        if (load.userData && load.userData.powerConsumption !== undefined) {
                            // Realistic power consumption fluctuation
                            const baseConsumption = load.userData.powerConsumption;
                            const timeOfDay = Math.sin(time * 0.1) * 0.5 + 0.5; // Simulate day/night cycle
                            const randomVariation = Math.sin(time * 5 + load.userData.flickerPhase) * 0.1;
                            
                            const currentConsumption = baseConsumption * timeOfDay + randomVariation;
                            
                            if (load.material && load.material.emissive) {
                                // Houses glow based on power consumption
                                const glowIntensity = Math.max(0, currentConsumption) * 0.3;
                                load.material.emissive.setScalar(glowIntensity);
                                
                                // Occasional power surge effect
                                if (Math.random() < 0.001) {
                                    load.material.emissive.setScalar(0.8);
                                    setTimeout(() => {
                                        if (load.material) {
                                            load.material.emissive.setScalar(glowIntensity);
                                        }
                                    }, 200);
                                }
                            }
                        }
                    });
                }
                
                // Power monitoring display animation
                const monitoringGroup = scene.userData.monitoringGroup;
                if (monitoringGroup && monitoringGroup.children[0]) {
                    const display = monitoringGroup.children[0];
                    if (display.material && display.material.emissive) {
                        // Simulate real-time power monitoring data
                        const dataUpdate = Math.sin(time * 8) * 0.1 + 0.4;
                        display.material.emissive.setScalar(dataUpdate);
                        
                        // Occasional data refresh flash
                        if (Math.floor(time * 2) % 5 === 0 && time * 2 % 1 < 0.1) {
                            display.material.emissive.setScalar(0.8);
                        }
                    }
                }
                
                // Animate transmission line sway from wind
                const powerLines = scene.userData.powerLines;
                if (powerLines) {
                    powerLines.forEach((line, index) => {
                        const windEffect = Math.sin(time * 1.5 + index * 0.5) * 0.02;
                        line.rotation.z = windEffect;
                        line.position.z = Math.sin(time + index) * 0.05;
                    });
                }
            }
            
            setupEventListeners() {
                // Navigation buttons
                document.getElementById('audio-btn').addEventListener('click', () => this.toggleAudio());
                document.getElementById('fullscreen-btn').addEventListener('click', () => this.toggleFullscreen());
                document.getElementById('home-btn').addEventListener('click', () => this.goHome());
                
                // Progress dots
                document.querySelectorAll('.progress-dot').forEach((dot, index) => {
                    dot.addEventListener('click', () => this.navigateToSection(index));
                });
                
                // Window resize handler
                window.addEventListener('resize', () => this.handleResize());
                
                // Enhanced scroll behavior
                this.setupScrollBehavior();
            }
            
            setupScrollBehavior() {
                let scrollTimeout;
                let isScrolling = false;
                
                // Track scroll events
                window.addEventListener('scroll', () => {
                    if (isScrolling) return;
                    
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                        this.handleScrollNavigation();
                    }, 150);
                });
                
                // Enhanced keyboard navigation with scroll
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    switch(e.key) {
                        case 'ArrowDown':
                        case 'ArrowRight':
                        case ' ':
                            e.preventDefault();
                            this.nextSectionWithScroll();
                            break;
                        case 'ArrowUp':
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.previousSectionWithScroll();
                            break;
                        case 'Home':
                            e.preventDefault();
                            this.navigateToSectionWithScroll(0);
                            break;
                        case 'End':
                            e.preventDefault();
                            this.navigateToSectionWithScroll(this.totalSections - 1);
                            break;
                        case 'Escape':
                            e.preventDefault();
                            if (document.fullscreenElement) {
                                document.exitFullscreen();
                            }
                            break;
                        case 'm':
                        case 'M':
                            e.preventDefault();
                            this.toggleAudio();
                            break;
                    }
                });
                
                // Mouse wheel enhanced scrolling
                window.addEventListener('wheel', (e) => {
                    if (Math.abs(e.deltaY) > 50) { // Significant scroll
                        e.preventDefault();
                        if (e.deltaY > 0) {
                            this.nextSectionWithScroll();
                        } else {
                            this.previousSectionWithScroll();
                        }
                    }
                }, { passive: false });
            }
            
            handleScrollNavigation() {
                const sections = document.querySelectorAll('.content-section');
                const viewportHeight = window.innerHeight;
                let currentIndex = 0;
                
                sections.forEach((section, index) => {
                    const rect = section.getBoundingClientRect();
                    if (rect.top <= viewportHeight / 2 && rect.bottom >= viewportHeight / 2) {
                        currentIndex = index;
                    }
                });
                
                if (currentIndex !== this.currentSection) {
                    this.navigateToSection(currentIndex, false); // Don't trigger scroll
                }
            }
            
            nextSectionWithScroll() {
                if (this.currentSection < this.totalSections - 1) {
                    this.navigateToSectionWithScroll(this.currentSection + 1);
                }
            }
            
            previousSectionWithScroll() {
                if (this.currentSection > 0) {
                    this.navigateToSectionWithScroll(this.currentSection - 1);
                }
            }
            
            navigateToSectionWithScroll(index) {
                if (index >= 0 && index < this.totalSections) {
                    this.navigateToSection(index, true);
                }
            }
            
            handleResize() {
                Object.keys(this.renderers).forEach(name => {
                    const canvas = document.getElementById(`${name}-canvas`);
                    const container = canvas.parentElement;
                    
                    this.cameras[name].aspect = container.clientWidth / container.clientHeight;
                    this.cameras[name].updateProjectionMatrix();
                    this.renderers[name].setSize(container.clientWidth, container.clientHeight);
                });
            }
            
            setupKeyboardNavigation() {
                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case 'ArrowDown':
                        case 'ArrowRight':
                        case ' ':
                            e.preventDefault();
                            this.nextSection();
                            break;
                        case 'ArrowUp':
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.previousSection();
                            break;
                        case 'Home':
                            e.preventDefault();
                            this.navigateToSection(0);
                            break;
                        case 'End':
                            e.preventDefault();
                            this.navigateToSection(this.totalSections - 1);
                            break;
                        case 'Escape':
                            e.preventDefault();
                            if (document.fullscreenElement) {
                                document.exitFullscreen();
                            }
                            break;
                    }
                });
            }
            
            navigateToSection(index, shouldScroll = true) {
                if (index >= 0 && index < this.totalSections) {
                    this.currentSection = index;
                    this.updateDisplay(shouldScroll);
                    this.logSectionInfo(index);
                    this.narrateSection(index);
                }
            }
            
            nextSection() {
                if (this.currentSection < this.totalSections - 1) {
                    this.navigateToSection(this.currentSection + 1);
                }
            }
            
            previousSection() {
                if (this.currentSection > 0) {
                    this.navigateToSection(this.currentSection - 1);
                }
            }
            
            updateDisplay(shouldScroll = true) {
                // Update section counter
                document.getElementById('current-section').textContent = this.currentSection + 1;
                document.getElementById('total-sections').textContent = this.totalSections;
                
                // Update progress dots with smooth animation
                document.querySelectorAll('.progress-dot').forEach((dot, index) => {
                    dot.classList.toggle('active', index === this.currentSection);
                    if (index === this.currentSection) {
                        dot.style.transform = 'scale(1.2)';
                        dot.style.transition = 'all 0.3s ease';
                    } else {
                        dot.style.transform = 'scale(1)';
                    }
                });
                
                // Update content sections with fade transition
                document.querySelectorAll('.content-section').forEach((section, index) => {
                    if (index === this.currentSection) {
                        section.classList.add('active');
                        section.style.opacity = '1';
                        section.style.transform = 'translateY(0)';
                    } else {
                        section.classList.remove('active');
                        section.style.opacity = '0.3';
                        section.style.transform = 'translateY(20px)';
                    }
                    section.style.transition = 'all 0.5s ease';
                });
                
                // Start current visualization
                this.startCurrentVisualization();
                
                // Enhanced smooth scroll to current section
                if (shouldScroll) {
                    const activeSection = document.querySelector('.content-section.active');
                    if (activeSection) {
                        const headerHeight = 80; // Account for fixed header
                        const targetPosition = activeSection.offsetTop - headerHeight;
                        
                        window.scrollTo({
                            top: targetPosition,
                            behavior: 'smooth'
                        });
                    }
                }
            }
            
            toggleAudio() {
                this.audioEnabled = !this.audioEnabled;
                const audioBtn = document.getElementById('audio-btn');
                audioBtn.textContent = this.audioEnabled ? '🔊' : '🔇';
                audioBtn.title = this.audioEnabled ? 'Disable Audio (Press M)' : 'Enable Audio (Press M)';
                
                // Visual feedback
                audioBtn.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    audioBtn.style.transform = 'scale(1)';
                }, 200);
                
                if (!this.audioEnabled) {
                    if (window.cartesiaTTS) {
                        window.cartesiaTTS.stop();
                    }
                } else if (this.audioEnabled) {
                    setTimeout(() => {
                        const message = "Audio narration enabled. Educational descriptions will now play for each section.";
                        if (window.cartesiaTTS) {
                            window.cartesiaTTS.speak(message);
                        }
                    }, 300);
                }
            }
            
            toggleFullscreen() {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.documentElement.requestFullscreen();
                }
            }
            
            goHome() {
                window.location.href = 'index.html';
            }
            
            showCompletion() {
                document.getElementById('completion-modal').classList.add('active');
                
                if (this.audioEnabled) {
                    const message = "Congratulations! You have completed the Electrical Concepts experience. You now understand the fundamental principles of electricity from charge to power.";
                    if (window.cartesiaTTS) {
                        window.cartesiaTTS.speak(message);
                    }
                }
            }
            
            restartExperience() {
                document.getElementById('completion-modal').classList.remove('active');
                this.navigateToSection(0);
            }
            
            exploreMore() {
                window.location.href = 'index.html';
            }
            
            logSectionInfo(index) {
                const topics = [
                    'Electric Charge: Coulomb force F = k(q₁q₂)/r² with elementary charge interactions',
                    'Electric Current: I = nAv_d e with realistic electron drift velocities',
                    'Resistance: R = ρL/A with material-specific resistivity values',
                    'Voltage: V = W/Q with electric potential and field relationships',
                    'Ohm\'s Law: V = IR demonstrating voltage-current-resistance relationship',
                    'Circuit Components: Resistors, capacitors, and other fundamental elements',
                    'Circuit Configurations: Series and parallel connection analysis',
                    'Heating Effects: Joule heating P = I²R with thermal energy conversion',
                    'Electric Power: P = VI with energy transfer and efficiency concepts'
                ];
                
                console.log(`Section ${index + 1}: ${topics[index]}`);
            }
            
            startCurrentVisualization() {
                // All visualizations are already running in the main animate loop
                // This method is kept for compatibility
            }
            
            createComponentsVisualization(scene) {
                // Create various electronic components in 3D
                const componentsGroup = new THREE.Group();
                
                // 1. Resistor
                const resistorGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 16);
                const resistorMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const resistor = new THREE.Mesh(resistorGeometry, resistorMaterial);
                resistor.position.set(-2, 1, 0);
                resistor.rotation.z = Math.PI / 2;
                componentsGroup.add(resistor);
                
                // Resistor color bands
                const bandColors = [0xFFD700, 0xFF0000, 0x00FF00];
                bandColors.forEach((color, index) => {
                    const bandGeometry = new THREE.CylinderGeometry(0.11, 0.11, 0.05, 16);
                    const bandMaterial = new THREE.MeshPhongMaterial({ color });
                    const band = new THREE.Mesh(bandGeometry, bandMaterial);
                    band.position.set(-2.3 + index * 0.3, 1, 0);
                    band.rotation.z = Math.PI / 2;
                    componentsGroup.add(band);
                });
                
                // 2. Capacitor
                const plateGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.05);
                const plateMaterial = new THREE.MeshPhongMaterial({ color: 0x666666, metalness: 0.8 });
                
                const plate1 = new THREE.Mesh(plateGeometry, plateMaterial);
                plate1.position.set(0, 1, -0.15);
                componentsGroup.add(plate1);
                
                const plate2 = new THREE.Mesh(plateGeometry, plateMaterial);
                plate2.position.set(0, 1, 0.15);
                componentsGroup.add(plate2);
                
                // Dielectric between plates
                const dielectricGeometry = new THREE.BoxGeometry(0.5, 0.7, 0.2);
                const dielectricMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x00ff88, 
                    transparent: true, 
                    opacity: 0.6 
                });
                const dielectric = new THREE.Mesh(dielectricGeometry, dielectricMaterial);
                dielectric.position.set(0, 1, 0);
                componentsGroup.add(dielectric);
                
                // 3. Inductor (coil)
                const coilGroup = new THREE.Group();
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 8; // Multiple turns
                    const coilRadius = 0.3;
                    const height = (i / 20) * 1;
                    
                    const segmentGeometry = new THREE.TorusGeometry(coilRadius, 0.02, 4, 8);
                    const segmentMaterial = new THREE.MeshPhongMaterial({ color: 0xCC6600 });
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    segment.position.set(0, height - 0.5, 0);
                    segment.rotation.x = Math.PI / 2;
                    coilGroup.add(segment);
                }
                coilGroup.position.set(2, 1, 0);
                componentsGroup.add(coilGroup);
                
                // 4. LED
                const ledBodyGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.4, 16);
                const ledBodyMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const ledBody = new THREE.Mesh(ledBodyGeometry, ledBodyMaterial);
                ledBody.position.set(-2, -1, 0);
                componentsGroup.add(ledBody);
                
                const ledLensGeometry = new THREE.SphereGeometry(0.12, 16, 16);
                const ledLensMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff4444, 
                    emissive: 0x441111,
                    transparent: true,
                    opacity: 0.8
                });
                const ledLens = new THREE.Mesh(ledLensGeometry, ledLensMaterial);
                ledLens.position.set(-2, -0.8, 0);
                componentsGroup.add(ledLens);
                
                // 5. Transistor
                const transistorGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
                const transistorMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
                const transistor = new THREE.Mesh(transistorGeometry, transistorMaterial);
                transistor.position.set(0, -1, 0);
                componentsGroup.add(transistor);
                
                // Transistor pins
                for (let i = 0; i < 3; i++) {
                    const pinGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
                    const pinMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                    const pin = new THREE.Mesh(pinGeometry, pinMaterial);
                    pin.position.set(-0.15 + i * 0.15, -1.3, 0);
                    componentsGroup.add(pin);
                }
                
                // 6. Integrated Circuit
                const icGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.1);
                const icMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
                const ic = new THREE.Mesh(icGeometry, icMaterial);
                ic.position.set(2, -1, 0);
                componentsGroup.add(ic);
                
                // IC pins
                for (let i = 0; i < 8; i++) {
                    const pinGeometry = new THREE.BoxGeometry(0.03, 0.1, 0.02);
                    const pinMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                    const pin = new THREE.Mesh(pinGeometry, pinMaterial);
                    const side = i < 4 ? -1 : 1;
                    const index = i < 4 ? i : i - 4;
                    pin.position.set(2 + side * 0.5, -1 - 0.15 + index * 0.1, 0);
                    componentsGroup.add(pin);
                }
                
                scene.add(componentsGroup);
                scene.userData = { componentsGroup };
            }
            
            createConfigurationsVisualization(scene) {
                // Create comprehensive series vs parallel circuit comparison
                const mainGroup = new THREE.Group();
                
                // === SERIES CIRCUIT (LEFT SIDE) ===
                const seriesGroup = new THREE.Group();
                seriesGroup.position.set(-3.5, 0, 0);
                
                // Series circuit battery
                const batteryGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.2);
                const batteryMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const seriesBattery = new THREE.Mesh(batteryGeometry, batteryMaterial);
                seriesBattery.position.set(0, 0, 0);
                seriesGroup.add(seriesBattery);
                
                // Battery terminals with labels
                const terminalGeometry = new THREE.BoxGeometry(0.32, 0.1, 0.22);
                const positiveTerminal = new THREE.Mesh(terminalGeometry, new THREE.MeshPhongMaterial({ color: 0xff4444 }));
                positiveTerminal.position.set(0, 0.45, 0);
                seriesGroup.add(positiveTerminal);
                
                const negativeTerminal = new THREE.Mesh(terminalGeometry, new THREE.MeshPhongMaterial({ color: 0x4444ff }));
                negativeTerminal.position.set(0, -0.45, 0);
                seriesGroup.add(negativeTerminal);
                
                // Series resistors with different values for educational purpose
                const resistorValues = [100, 200, 300]; // Ohms
                const resistorColors = [0x8B4513, 0xA0522D, 0x654321];
                const seriesResistors = [];
                
                for (let i = 0; i < 3; i++) {
                    const resistorGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.6, 16);
                    const resistorMaterial = new THREE.MeshPhongMaterial({ color: resistorColors[i] });
                    const resistor = new THREE.Mesh(resistorGeometry, resistorMaterial);
                    resistor.position.set(1.5 + i * 1.2, 0.8, 0);
                    resistor.rotation.z = Math.PI / 2;
                    resistor.userData = { 
                        resistance: resistorValues[i],
                        current: 0,
                        voltage: 0,
                        index: i
                    };
                    seriesResistors.push(resistor);
                    seriesGroup.add(resistor);
                    
                    // Resistor color bands for value identification
                    const bandColors = [
                        [0xFFD700, 0xFF0000, 0x8B4513], // 100Ω - Yellow, Red, Brown
                        [0xFF0000, 0xFF0000, 0x8B4513], // 200Ω - Red, Red, Brown  
                        [0xFFA500, 0xFF0000, 0x8B4513]  // 300Ω - Orange, Red, Brown
                    ];
                    
                    bandColors[i].forEach((color, bandIndex) => {
                        const bandGeometry = new THREE.CylinderGeometry(0.13, 0.13, 0.08, 16);
                        const bandMaterial = new THREE.MeshPhongMaterial({ color });
                        const band = new THREE.Mesh(bandGeometry, bandMaterial);
                        band.position.set(1.2 + i * 1.2 + bandIndex * 0.15, 0.8, 0);
                        band.rotation.z = Math.PI / 2;
                        seriesGroup.add(band);
                    });
                }
                
                // Series circuit wires with proper 3D appearance
                const wireRadius = 0.03;
                const wireMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                
                // Top wire segments
                const topWireSegments = [
                    { start: [0.15, 0.45, 0], end: [0.9, 0.8, 0] },
                    { start: [2.1, 0.8, 0], end: [2.7, 0.8, 0] },
                    { start: [3.3, 0.8, 0], end: [3.9, 0.8, 0] },
                    { start: [4.5, 0.8, 0], end: [5, 0.8, 0] }
                ];
                
                topWireSegments.forEach(segment => {
                    const direction = new THREE.Vector3(...segment.end).sub(new THREE.Vector3(...segment.start));
                    const length = direction.length();
                    direction.normalize();
                    
                    const wireGeometry = new THREE.CylinderGeometry(wireRadius, wireRadius, length, 8);
                    const wire = new THREE.Mesh(wireGeometry, wireMaterial);
                    
                    wire.position.copy(new THREE.Vector3(...segment.start).add(new THREE.Vector3(...segment.end)).multiplyScalar(0.5));
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                    wire.setRotationFromQuaternion(quaternion);
                    
                    seriesGroup.add(wire);
                });
                
                // Vertical and bottom wires
                const otherWireSegments = [
                    { start: [5, 0.8, 0], end: [5, -0.8, 0] }, // Right vertical
                    { start: [5, -0.8, 0], end: [0.15, -0.45, 0] } // Bottom
                ];
                
                otherWireSegments.forEach(segment => {
                    const direction = new THREE.Vector3(...segment.end).sub(new THREE.Vector3(...segment.start));
                    const length = direction.length();
                    direction.normalize();
                    
                    const wireGeometry = new THREE.CylinderGeometry(wireRadius, wireRadius, length, 8);
                    const wire = new THREE.Mesh(wireGeometry, wireMaterial);
                    
                    wire.position.copy(new THREE.Vector3(...segment.start).add(new THREE.Vector3(...segment.end)).multiplyScalar(0.5));
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                    wire.setRotationFromQuaternion(quaternion);
                    
                    seriesGroup.add(wire);
                });
                
                // Series current indicators
                const seriesCurrentParticles = [];
                const seriesPath = [
                    new THREE.Vector3(0.15, 0.45, 0),
                    new THREE.Vector3(0.9, 0.8, 0),
                    new THREE.Vector3(2.1, 0.8, 0),
                    new THREE.Vector3(2.7, 0.8, 0),
                    new THREE.Vector3(3.3, 0.8, 0),
                    new THREE.Vector3(3.9, 0.8, 0),
                    new THREE.Vector3(4.5, 0.8, 0),
                    new THREE.Vector3(5, 0.8, 0),
                    new THREE.Vector3(5, 0, 0),
                    new THREE.Vector3(5, -0.8, 0),
                    new THREE.Vector3(2.5, -0.8, 0),
                    new THREE.Vector3(0.15, -0.45, 0)
                ];
                
                for (let i = 0; i < 8; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.04, 12, 12);
                    const particleMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xffff00,
                        emissive: 0x444400
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.userData = { 
                        progress: i / 8,
                        path: seriesPath,
                        type: 'series'
                    };
                    seriesCurrentParticles.push(particle);
                    seriesGroup.add(particle);
                }
                
                // Series voltage meters
                const voltmeterGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.1);
                const meterMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
                
                for (let i = 0; i < 3; i++) {
                    const voltmeter = new THREE.Mesh(voltmeterGeometry, meterMaterial);
                    voltmeter.position.set(1.5 + i * 1.2, 1.3, 0);
                    voltmeter.userData = { resistorIndex: i, type: 'voltmeter' };
                    seriesGroup.add(voltmeter);
                    
                    // Meter display
                    const displayGeometry = new THREE.PlaneGeometry(0.3, 0.2);
                    const displayMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x004400,
                        emissive: 0x002200
                    });
                    const display = new THREE.Mesh(displayGeometry, displayMaterial);
                    display.position.set(1.5 + i * 1.2, 1.3, 0.06);
                    seriesGroup.add(display);
                }
                
                // Current meter for series
                const ammeter = new THREE.Mesh(voltmeterGeometry, meterMaterial);
                ammeter.position.set(0.5, 0.8, 0);
                seriesGroup.add(ammeter);
                
                mainGroup.add(seriesGroup);
                
                // === PARALLEL CIRCUIT (RIGHT SIDE) ===
                const parallelGroup = new THREE.Group();
                parallelGroup.position.set(3.5, 0, 0);
                
                // Parallel circuit battery
                const parallelBattery = new THREE.Mesh(batteryGeometry, batteryMaterial);
                parallelBattery.position.set(0, 0, 0);
                parallelGroup.add(parallelBattery);
                
                // Battery terminals
                const parallelPositiveTerminal = new THREE.Mesh(terminalGeometry, new THREE.MeshPhongMaterial({ color: 0xff4444 }));
                parallelPositiveTerminal.position.set(0, 0.45, 0);
                parallelGroup.add(parallelPositiveTerminal);
                
                const parallelNegativeTerminal = new THREE.Mesh(terminalGeometry, new THREE.MeshPhongMaterial({ color: 0x4444ff }));
                parallelNegativeTerminal.position.set(0, -0.45, 0);
                parallelGroup.add(parallelNegativeTerminal);
                
                // Parallel resistors with same values for comparison
                const parallelResistors = [];
                const parallelResistorValue = 300; // All same value
                
                for (let i = 0; i < 3; i++) {
                    const resistorGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.6, 16);
                    const resistorMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                    const resistor = new THREE.Mesh(resistorGeometry, resistorMaterial);
                    resistor.position.set(2.5, 1 - i * 1, 0);
                    resistor.rotation.z = Math.PI / 2;
                    resistor.userData = { 
                        resistance: parallelResistorValue,
                        current: 0,
                        voltage: 0,
                        branch: i
                    };
                    parallelResistors.push(resistor);
                    parallelGroup.add(resistor);
                    
                    // Color bands for parallel resistors (all same: 300Ω)
                    const bandColors = [0xFFA500, 0xFF0000, 0x8B4513]; // Orange, Red, Brown
                    bandColors.forEach((color, bandIndex) => {
                        const bandGeometry = new THREE.CylinderGeometry(0.13, 0.13, 0.08, 16);
                        const bandMaterial = new THREE.MeshPhongMaterial({ color });
                        const band = new THREE.Mesh(bandGeometry, bandMaterial);
                        band.position.set(2.2 + bandIndex * 0.15, 1 - i * 1, 0);
                        band.rotation.z = Math.PI / 2;
                        parallelGroup.add(band);
                    });
                }
                
                // Parallel circuit wires - junction design
                const junctionWires = [
                    // Main positive line
                    { start: [0.15, 0.45, 0], end: [1.5, 0.45, 0] },
                    { start: [1.5, 0.45, 0], end: [1.5, 1, 0] },
                    
                    // Branch connections to positive junction
                    { start: [1.5, 1, 0], end: [1.9, 1, 0] },
                    { start: [1.5, 0.45, 0], end: [1.9, 0, 0] },
                    { start: [1.5, 0.45, 0], end: [1.5, -1, 0] },
                    { start: [1.5, -1, 0], end: [1.9, -1, 0] },
                    
                    // After resistors to negative junction
                    { start: [3.1, 1, 0], end: [3.5, 1, 0] },
                    { start: [3.1, 0, 0], end: [3.5, 0, 0] },
                    { start: [3.1, -1, 0], end: [3.5, -1, 0] },
                    
                    // Negative junction
                    { start: [3.5, 1, 0], end: [3.5, -0.45, 0] },
                    { start: [3.5, -0.45, 0], end: [0.15, -0.45, 0] }
                ];
                
                junctionWires.forEach(segment => {
                    const direction = new THREE.Vector3(...segment.end).sub(new THREE.Vector3(...segment.start));
                    const length = direction.length();
                    direction.normalize();
                    
                    const wireGeometry = new THREE.CylinderGeometry(wireRadius, wireRadius, length, 8);
                    const wire = new THREE.Mesh(wireGeometry, wireMaterial);
                    
                    wire.position.copy(new THREE.Vector3(...segment.start).add(new THREE.Vector3(...segment.end)).multiplyScalar(0.5));
                    const quaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
                    wire.setRotationFromQuaternion(quaternion);
                    
                    parallelGroup.add(wire);
                });
                
                // Parallel current particles (different colors for each branch)
                const parallelCurrentParticles = [];
                const branchColors = [0xff4444, 0x44ff44, 0x4444ff];
                
                for (let branch = 0; branch < 3; branch++) {
                    const branchPaths = [
                        [ // Top branch
                            new THREE.Vector3(1.5, 1, 0),
                            new THREE.Vector3(1.9, 1, 0),
                            new THREE.Vector3(3.1, 1, 0),
                            new THREE.Vector3(3.5, 1, 0)
                        ],
                        [ // Middle branch
                            new THREE.Vector3(1.5, 0, 0),
                            new THREE.Vector3(1.9, 0, 0),
                            new THREE.Vector3(3.1, 0, 0),
                            new THREE.Vector3(3.5, 0, 0)
                        ],
                        [ // Bottom branch
                            new THREE.Vector3(1.5, -1, 0),
                            new THREE.Vector3(1.9, -1, 0),
                            new THREE.Vector3(3.1, -1, 0),
                            new THREE.Vector3(3.5, -1, 0)
                        ]
                    ];
                    
                    for (let i = 0; i < 4; i++) {
                        const particleGeometry = new THREE.SphereGeometry(0.04, 12, 12);
                        const particleMaterial = new THREE.MeshPhongMaterial({ 
                            color: branchColors[branch],
                            emissive: new THREE.Color(branchColors[branch]).multiplyScalar(0.3)
                        });
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.userData = { 
                            progress: i / 4,
                            path: branchPaths[branch],
                            branch: branch,
                            type: 'parallel'
                        };
                        parallelCurrentParticles.push(particle);
                        parallelGroup.add(particle);
                    }
                }
                
                // Parallel voltage and current meters
                for (let i = 0; i < 3; i++) {
                    // Voltage meter (same for all branches in parallel)
                    const voltmeter = new THREE.Mesh(voltmeterGeometry, meterMaterial);
                    voltmeter.position.set(2.5, 1.5 - i * 1, 0);
                    parallelGroup.add(voltmeter);
                    
                    // Current meter for each branch
                    const branchAmmeter = new THREE.Mesh(voltmeterGeometry, meterMaterial);
                    branchAmmeter.position.set(1.7, 1 - i * 1, 0);
                    parallelGroup.add(branchAmmeter);
                }
                
                mainGroup.add(parallelGroup);
                
                // === EDUCATIONAL LABELS ===
                const labelGroup = new THREE.Group();
                
                // Series circuit label
                const seriesLabelGeometry = new THREE.PlaneGeometry(2, 0.5);
                const seriesLabelMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x4a9eff,
                    transparent: true,
                    opacity: 0.8
                });
                const seriesLabel = new THREE.Mesh(seriesLabelGeometry, seriesLabelMaterial);
                seriesLabel.position.set(-3.5, 2.5, 0);
                labelGroup.add(seriesLabel);
                
                // Parallel circuit label
                const parallelLabel = new THREE.Mesh(seriesLabelGeometry, seriesLabelMaterial);
                parallelLabel.position.set(3.5, 2.5, 0);
                labelGroup.add(parallelLabel);
                
                // Information panels
                const infoGeometry = new THREE.PlaneGeometry(1.5, 1);
                const infoMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x222222,
                    transparent: true,
                    opacity: 0.7
                });
                
                const seriesInfo = new THREE.Mesh(infoGeometry, infoMaterial);
                seriesInfo.position.set(-3.5, -2.5, 0);
                labelGroup.add(seriesInfo);
                
                const parallelInfo = new THREE.Mesh(infoGeometry, infoMaterial);
                parallelInfo.position.set(3.5, -2.5, 0);
                labelGroup.add(parallelInfo);
                
                mainGroup.add(labelGroup);
                
                scene.add(mainGroup);
                
                scene.userData = { 
                    mainGroup,
                    seriesGroup,
                    parallelGroup,
                    seriesResistors,
                    parallelResistors,
                    seriesCurrentParticles,
                    parallelCurrentParticles,
                    labelGroup
                };
            }
            
            createHeatingVisualization(scene) {
                // Create multiple heating elements with different temperatures
                const heatingGroup = new THREE.Group();
                
                // Main toaster-style heating coil
                const mainCoilGroup = new THREE.Group();
                for (let i = 0; i < 150; i++) {
                    const angle = (i / 150) * Math.PI * 16; // More spirals
                    const radius = 0.8 + Math.sin(i * 0.15) * 0.15;
                    const height = (i / 150) * 3 - 1.5;
                    
                    const segmentGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.08, 8);
                    const temperature = 0.7 + Math.sin(i * 0.08) * 0.25 + Math.random() * 0.1;
                    
                    const segmentMaterial = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color().setHSL(0.12 - temperature * 0.12, 1, 0.2 + temperature * 0.6),
                        emissive: new THREE.Color().setHSL(0.08 - temperature * 0.08, 1, temperature * 0.4)
                    });
                    
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    segment.position.set(
                        Math.cos(angle) * radius,
                        height,
                        Math.sin(angle) * radius
                    );
                    segment.userData = { 
                        baseTemperature: temperature,
                        segmentIndex: i,
                        maxTemp: 1.2
                    };
                    mainCoilGroup.add(segment);
                }
                mainCoilGroup.position.set(0, 0, 0);
                heatingGroup.add(mainCoilGroup);
                
                // Secondary heating strips
                for (let strip = 0; strip < 4; strip++) {
                    const stripGroup = new THREE.Group();
                    const stripAngle = (strip / 4) * Math.PI * 2;
                    const stripRadius = 1.5;
                    
                    for (let i = 0; i < 20; i++) {
                        const segmentGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.15);
                        const temperature = 0.5 + i * 0.02 + Math.random() * 0.1;
                        
                        const segmentMaterial = new THREE.MeshPhongMaterial({ 
                            color: new THREE.Color().setHSL(0.1 - temperature * 0.1, 1, 0.3 + temperature * 0.5),
                            emissive: new THREE.Color().setHSL(0.05 - temperature * 0.05, 1, temperature * 0.3)
                        });
                        
                        const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                        segment.position.set(
                            Math.cos(stripAngle) * stripRadius,
                            -1.5 + i * 0.15,
                            Math.sin(stripAngle) * stripRadius
                        );
                        segment.userData = { 
                            baseTemperature: temperature,
                            segmentIndex: i,
                            strip: strip
                        };
                        stripGroup.add(segment);
                    }
                    heatingGroup.add(stripGroup);
                }
                
                scene.add(heatingGroup);
                
                // Enhanced heat particles with multiple types
                const heatParticles = [];
                const smokeParticles = [];
                const sparkParticles = [];
                
                // Rising heat particles
                for (let i = 0; i < 80; i++) {
                    const heatGeometry = new THREE.SphereGeometry(0.015 + Math.random() * 0.01, 6, 6);
                    const heatMaterial = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(0.08 + Math.random() * 0.04, 1, 0.7 + Math.random() * 0.3),
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const particle = new THREE.Mesh(heatGeometry, heatMaterial);
                    particle.position.set(
                        (Math.random() - 0.5) * 3,
                        -1.5 + Math.random() * 0.5,
                        (Math.random() - 0.5) * 3
                    );
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.02,
                            0.03 + Math.random() * 0.04,
                            (Math.random() - 0.5) * 0.02
                        ),
                        life: Math.random(),
                        initialY: particle.position.y,
                        rotationSpeed: (Math.random() - 0.5) * 0.1,
                        type: 'heat'
                    };
                    
                    heatParticles.push(particle);
                    scene.add(particle);
                }
                
                // Smoke particles
                for (let i = 0; i < 40; i++) {
                    const smokeGeometry = new THREE.SphereGeometry(0.02 + Math.random() * 0.02, 6, 6);
                    const smokeMaterial = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(0, 0, 0.2 + Math.random() * 0.3),
                        transparent: true,
                        opacity: 0.4
                    });
                    
                    const particle = new THREE.Mesh(smokeGeometry, smokeMaterial);
                    particle.position.set(
                        (Math.random() - 0.5) * 2,
                        -1 + Math.random() * 0.5,
                        (Math.random() - 0.5) * 2
                    );
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.01,
                            0.02 + Math.random() * 0.02,
                            (Math.random() - 0.5) * 0.01
                        ),
                        life: Math.random(),
                        initialY: particle.position.y,
                        expansionRate: 1 + Math.random() * 0.5,
                        type: 'smoke'
                    };
                    
                    smokeParticles.push(particle);
                    scene.add(particle);
                }
                
                // Spark particles
                for (let i = 0; i < 15; i++) {
                    const sparkGeometry = new THREE.SphereGeometry(0.005 + Math.random() * 0.01, 4, 4);
                    const sparkMaterial = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(0.15, 1, 0.9),
                        emissive: new THREE.Color().setHSL(0.15, 1, 0.6)
                    });
                    
                    const particle = new THREE.Mesh(sparkGeometry, sparkMaterial);
                    particle.position.set(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2
                    );
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.05
                        ),
                        life: Math.random(),
                        initialLife: Math.random(),
                        type: 'spark'
                    };
                    
                    sparkParticles.push(particle);
                    scene.add(particle);
                }
                
                // Enhanced thermal radiation visualization with multiple layers
                const radiationLayers = [];
                
                for (let layer = 0; layer < 3; layer++) {
                    const radiationGeometry = new THREE.SphereGeometry(2.5 + layer * 0.8, 32, 32);
                    const radiationMaterial = new THREE.ShaderMaterial({
                        vertexShader: `
                            varying vec3 vPosition;
                            varying vec3 vNormal;
                            void main() {
                                vPosition = position;
                                vNormal = normal;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform float layer;
                            varying vec3 vPosition;
                            varying vec3 vNormal;
                            
                            void main() {
                                float dist = length(vPosition);
                                float intensity = 1.0 / (dist * dist + 0.5);
                                
                                // Multiple wave patterns for more complex heat distribution
                                float wave1 = sin(time * 3.0 + dist * 8.0 + layer * 2.0) * 0.5 + 0.5;
                                float wave2 = sin(time * 2.0 + vPosition.y * 5.0) * 0.3 + 0.7;
                                float wave3 = sin(time * 4.0 + length(vPosition.xz) * 6.0) * 0.2 + 0.8;
                                
                                intensity *= wave1 * wave2 * wave3;
                                
                                // Different heat colors for each layer
                                vec3 heatColor1 = vec3(1.0, 0.2, 0.0); // Deep red
                                vec3 heatColor2 = vec3(1.0, 0.6, 0.1); // Orange
                                vec3 heatColor3 = vec3(1.0, 1.0, 0.4); // Yellow-white
                                
                                vec3 finalColor = mix(heatColor1, mix(heatColor2, heatColor3, layer / 2.0), intensity);
                                
                                float alpha = intensity * 0.15 * (1.0 - layer * 0.2);
                                gl_FragColor = vec4(finalColor, alpha);
                            }
                        `,
                        uniforms: {
                            time: { value: 0 },
                            layer: { value: layer }
                        },
                        transparent: true,
                        side: THREE.BackSide,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const radiationSphere = new THREE.Mesh(radiationGeometry, radiationMaterial);
                    radiationLayers.push(radiationSphere);
                    scene.add(radiationSphere);
                }
                
                // Infrared heat visualization
                const infraredGeometry = new THREE.PlaneGeometry(6, 6, 32, 32);
                const infraredMaterial = new THREE.ShaderMaterial({
                    vertexShader: `
                        varying vec2 vUv;
                        varying vec3 vPosition;
                        void main() {
                            vUv = uv;
                            vPosition = position;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        varying vec2 vUv;
                        varying vec3 vPosition;
                        
                        void main() {
                            vec2 center = vec2(0.5, 0.5);
                            float dist = distance(vUv, center);
                            
                            float heat = 1.0 / (dist * 3.0 + 0.2);
                            heat *= sin(time * 2.0 + dist * 10.0) * 0.3 + 0.7;
                            
                            vec3 infraredColor = vec3(heat * 0.8, heat * 0.2, heat * 0.1);
                            float alpha = heat * 0.3 * (1.0 - dist);
                            
                            gl_FragColor = vec4(infraredColor, alpha);
                        }
                    `,
                    uniforms: {
                        time: { value: 0 }
                    },
                    transparent: true,
                    side: THREE.DoubleSide
                });
                
                const infraredPlane = new THREE.Mesh(infraredGeometry, infraredMaterial);
                infraredPlane.rotation.x = -Math.PI / 2;
                infraredPlane.position.y = -2;
                scene.add(infraredPlane);
                
                scene.userData = { 
                    heatingGroup, 
                    mainCoilGroup,
                    heatParticles, 
                    smokeParticles,
                    sparkParticles,
                    radiationLayers,
                    infraredPlane
                };
            }
            
            createPowerVisualization(scene) {
                // Create comprehensive power transmission system
                const powerSystemGroup = new THREE.Group();
                
                // Enhanced Power Plant with cooling towers and turbine
                const powerPlantGroup = new THREE.Group();
                
                // Main generator building
                const buildingGeometry = new THREE.BoxGeometry(1.2, 1.5, 0.8);
                const buildingMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(-4, 0, 0);
                powerPlantGroup.add(building);
                
                // Cooling towers
                for (let i = 0; i < 2; i++) {
                    const towerGeometry = new THREE.CylinderGeometry(0.3, 0.5, 2, 16);
                    const towerMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                    tower.position.set(-4.5 + i * 1, 1, -1.5);
                    powerPlantGroup.add(tower);
                    
                    // Steam effect
                    const steamGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const steamMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff, 
                        transparent: true, 
                        opacity: 0.6 
                    });
                    for (let j = 0; j < 5; j++) {
                        const steam = new THREE.Mesh(steamGeometry, steamMaterial);
                        steam.position.set(
                            -4.5 + i * 1 + (Math.random() - 0.5) * 0.4,
                            2 + j * 0.3,
                            -1.5 + (Math.random() - 0.5) * 0.4
                        );
                        steam.userData = {
                            velocity: new THREE.Vector3(0, 0.02, 0),
                            life: Math.random(),
                            tower: i,
                            initialY: steam.position.y
                        };
                        powerPlantGroup.add(steam);
                    }
                }
                
                // Turbine generator
                const turbineHousingGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 16);
                const turbineHousingMaterial = new THREE.MeshPhongMaterial({ color: 0x4a9eff });
                const turbineHousing = new THREE.Mesh(turbineHousingGeometry, turbineHousingMaterial);
                turbineHousing.position.set(-4, 0, 0);
                turbineHousing.rotation.x = Math.PI / 2;
                powerPlantGroup.add(turbineHousing);
                
                // Turbine rotor with blades
                const rotorGroup = new THREE.Group();
                const shaftGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.4, 8);
                const shaftMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
                const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
                shaft.rotation.x = Math.PI / 2;
                rotorGroup.add(shaft);
                
                // Turbine blades
                for (let i = 0; i < 8; i++) {
                    const bladeGeometry = new THREE.BoxGeometry(0.02, 0.3, 0.1);
                    const bladeMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                    const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    blade.position.set(0, Math.cos(angle) * 0.25, Math.sin(angle) * 0.25);
                    blade.rotation.z = angle;
                    rotorGroup.add(blade);
                }
                rotorGroup.position.set(-4, 0, 0);
                powerPlantGroup.add(rotorGroup);
                
                powerSystemGroup.add(powerPlantGroup);
                
                // Enhanced Transmission Lines with realistic towers
                const transmissionGroup = new THREE.Group();
                
                // Transmission towers
                for (let tower = 0; tower < 3; tower++) {
                    const towerGroup = new THREE.Group();
                    const towerX = -1 + tower * 2;
                    
                    // Tower structure
                    const towerGeometry = new THREE.BoxGeometry(0.1, 3, 0.1);
                    const towerMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
                    const towerPole = new THREE.Mesh(towerGeometry, towerMaterial);
                    towerPole.position.set(towerX, 1.5, 0);
                    towerGroup.add(towerPole);
                    
                    // Cross arms
                    for (let arm = 0; arm < 3; arm++) {
                        const armGeometry = new THREE.BoxGeometry(1.5, 0.05, 0.05);
                        const armMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
                        const crossArm = new THREE.Mesh(armGeometry, armMaterial);
                        crossArm.position.set(towerX, 2.5 - arm * 0.4, 0);
                        towerGroup.add(crossArm);
                    }
                    
                    transmissionGroup.add(towerGroup);
                }
                
                // High voltage transmission lines with realistic sagging
                const powerLines = [];
                for (let line = 0; line < 3; line++) {
                    const lineY = 2.5 - line * 0.4;
                    const lineGeometry = new THREE.BufferGeometry();
                    const linePoints = [];
                    
                    // Create sagging cable curve
                    for (let i = 0; i <= 50; i++) {
                        const x = -1 + (i / 50) * 4;
                        const sag = Math.sin((i / 50) * Math.PI) * 0.2; // Realistic cable sag
                        linePoints.push(new THREE.Vector3(x, lineY - sag, 0));
                    }
                    
                    lineGeometry.setFromPoints(linePoints);
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
                    const powerLine = new THREE.Line(lineGeometry, lineMaterial);
                    powerLines.push(powerLine);
                    transmissionGroup.add(powerLine);
                }
                
                powerSystemGroup.add(transmissionGroup);
                
                // Enhanced Substation with realistic equipment
                const substationGroup = new THREE.Group();
                substationGroup.position.set(4, 0, 0);
                
                // Transformer bank
                for (let i = 0; i < 3; i++) {
                    const transformerGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
                    const transformerMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                    const transformer = new THREE.Mesh(transformerGeometry, transformerMaterial);
                    transformer.position.set(i * 0.8 - 0.8, 0.6, -1);
                    substationGroup.add(transformer);
                    
                    // Radiator fins
                    for (let fin = 0; fin < 8; fin++) {
                        const finGeometry = new THREE.BoxGeometry(0.02, 1, 0.1);
                        const finMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                        const radiatorFin = new THREE.Mesh(finGeometry, finMaterial);
                        radiatorFin.position.set(
                            i * 0.8 - 0.8 + 0.35,
                            0.6,
                            -1 - 0.4 + fin * 0.1
                        );
                        substationGroup.add(radiatorFin);
                    }
                }
                
                // Circuit breakers
                for (let i = 0; i < 4; i++) {
                    const breakerGeometry = new THREE.BoxGeometry(0.2, 0.6, 0.2);
                    const breakerMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                    const breaker = new THREE.Mesh(breakerGeometry, breakerMaterial);
                    breaker.position.set(i * 0.5 - 0.75, 0.3, 0.5);
                    substationGroup.add(breaker);
                }
                
                // Control building
                const controlBuildingGeometry = new THREE.BoxGeometry(1, 0.8, 0.6);
                const controlBuildingMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
                const controlBuilding = new THREE.Mesh(controlBuildingGeometry, controlBuildingMaterial);
                controlBuilding.position.set(0, 0.4, 1.5);
                substationGroup.add(controlBuilding);
                
                powerSystemGroup.add(substationGroup);
                
                // Distribution network
                const distributionGroup = new THREE.Group();
                
                // Distribution lines to homes/industry
                for (let i = 0; i < 5; i++) {
                    const poleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
                    const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                    const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                    pole.position.set(6 + i * 0.8, 1, -2 + i * 0.5);
                    distributionGroup.add(pole);
                    
                    // Distribution transformers
                    if (i % 2 === 0) {
                        const distTransformerGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.4, 8);
                        const distTransformerMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                        const distTransformer = new THREE.Mesh(distTransformerGeometry, distTransformerMaterial);
                        distTransformer.position.set(6 + i * 0.8, 2.2, -2 + i * 0.5);
                        distributionGroup.add(distTransformer);
                    }
                }
                
                powerSystemGroup.add(distributionGroup);
                
                // Enhanced Power Flow Visualization
                const powerParticles = [];
                const electricArcs = [];
                
                // Main transmission particles
                for (let line = 0; line < 3; line++) {
                    for (let i = 0; i < 15; i++) {
                        const particleGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                        const particleMaterial = new THREE.MeshPhongMaterial({ 
                            color: 0x00ffff,
                            emissive: 0x004488
                        });
                        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                        particle.position.set(-1 + i * 0.3, 2.5 - line * 0.4, 0);
                        particle.userData = {
                            line: line,
                            progress: i / 15,
                            speed: 0.025 + line * 0.005,
                            amplitude: 0.1 + Math.random() * 0.05,
                            frequency: 2 + Math.random()
                        };
                        powerParticles.push(particle);
                        scene.add(particle);
                    }
                }
                
                // Electrical arcing effects at substations
                for (let i = 0; i < 8; i++) {
                    const arcGeometry = new THREE.SphereGeometry(0.02, 6, 6);
                    const arcMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        emissive: 0x8888ff
                    });
                    const arc = new THREE.Mesh(arcGeometry, arcMaterial);
                    arc.position.set(
                        4 + (Math.random() - 0.5) * 2,
                        1 + Math.random() * 1.5,
                        (Math.random() - 0.5) * 2
                    );
                    arc.userData = {
                        life: Math.random(),
                        intensity: Math.random(),
                        flickerSpeed: 5 + Math.random() * 5
                    };
                    electricArcs.push(arc);
                    scene.add(arc);
                }
                
                // Load centers (cities/industry)
                const loadGroup = new THREE.Group();
                
                // Industrial complex
                const industryGeometry = new THREE.BoxGeometry(1.5, 1, 1);
                const industryMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
                const industry = new THREE.Mesh(industryGeometry, industryMaterial);
                industry.position.set(8, 0.5, -3);
                loadGroup.add(industry);
                
                // Residential area
                for (let i = 0; i < 6; i++) {
                    const houseGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.3);
                    const houseMaterial = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 0.5, 0.6) 
                    });
                    const house = new THREE.Mesh(houseGeometry, houseMaterial);
                    house.position.set(
                        7 + (i % 3) * 0.4,
                        0.2,
                        1 + Math.floor(i / 3) * 0.4
                    );
                    house.userData = {
                        powerConsumption: 0.5 + Math.random() * 0.5,
                        flickerPhase: Math.random() * Math.PI * 2
                    };
                    loadGroup.add(house);
                    
                    // House lighting
                    const lightGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const lightMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffcc,
                        emissive: 0x444400
                    });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.copy(house.position);
                    light.position.y += 0.3;
                    light.userData = house.userData;
                    loadGroup.add(light);
                }
                
                powerSystemGroup.add(loadGroup);
                
                // Real-time power monitoring display
                const monitoringGroup = new THREE.Group();
                const displayGeometry = new THREE.PlaneGeometry(1.5, 1);
                const displayMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x001100,
                    emissive: 0x004400
                });
                const powerDisplay = new THREE.Mesh(displayGeometry, displayMaterial);
                powerDisplay.position.set(0, 3, 0);
                powerDisplay.rotation.x = -Math.PI / 6;
                monitoringGroup.add(powerDisplay);
                
                powerSystemGroup.add(monitoringGroup);
                
                scene.add(powerSystemGroup);
                
                scene.userData = { 
                    powerSystemGroup,
                    powerPlantGroup,
                    rotorGroup,
                    transmissionGroup,
                    substationGroup,
                    distributionGroup,
                    loadGroup,
                    powerParticles,
                    electricArcs,
                    powerLines,
                    monitoringGroup
                };
            }
            
            narrateSection(index) {
                if (!this.audioEnabled) return;
                
                // Cancel any ongoing speech
                if (window.cartesiaTTS) {
                    window.cartesiaTTS.stop();
                }
                
                // Educational narration content for each section
                const narrations = [
                    // Electric Charge
                    "Welcome to the world of electric charge! You're now observing the fundamental interaction between positive and negative charges. Watch as the blue negative charge is attracted to the red positive charge by Coulomb's force. This force follows the inverse square law - as distance decreases, the attractive force increases dramatically. Notice how the field lines show the direction of the electric field, and the equipotential surfaces represent regions of equal electric potential.",
                    
                    // Electric Current
                    "Now we explore electric current - the flow of electric charge. You're seeing a realistic simulation of electron drift in a copper wire. The large copper atoms vibrate due to thermal motion, while the blue electrons move both randomly and with a small drift velocity in the direction opposite to conventional current. Notice how electrons collide with atoms, creating resistance to the flow. The yellow sparks show these collision events that convert electrical energy to heat.",
                    
                    // Resistance
                    "This visualization demonstrates electrical resistance - the opposition to current flow. You can see how different materials have different resistivities. Watch the electrons colliding more frequently with atoms as temperature increases, explaining why resistance typically increases with temperature. The heating elements show how electrical energy is converted to thermal energy through these collisions, following the relationship P equals I squared R.",
                    
                    // Voltage
                    "Voltage represents the electric potential difference that drives current flow. Think of it as the 'electrical pressure' that pushes charges through a circuit. You're seeing how voltage creates an electric field that gives electrons the energy to move. The relationship between voltage, current, and resistance is fundamental to all electrical phenomena.",
                    
                    // Ohm's Law
                    "Here's Ohm's Law in action: V equals I R. This fundamental relationship shows how voltage, current, and resistance are interconnected. Watch the circular path where electrons flow from the battery, through the resistor, and back to complete the circuit. The particles show actual current flow, and you can see how changing voltage affects the current flow rate through the circuit.",
                    
                    // Circuit Components
                    "These are the building blocks of all electronic devices. The resistor controls current flow with its color bands indicating resistance value. The capacitor stores electrical energy in its electric field between the plates. The inductor stores energy in its magnetic field. The LED converts electrical energy to light, and the transistor acts as an electronic switch or amplifier. Each component has a unique role in circuit design.",
                    
                    // Circuit Configurations
                    "Compare series and parallel circuits side by side. In the series circuit on the left, current flows through each component sequentially - the same current flows through all components, but voltage divides among them. In the parallel circuit on the right, voltage remains the same across all branches, but current divides. Notice how the total resistance differs: series resistance adds up, while parallel resistance decreases the total.",
                    
                    // Heating Effects
                    "Witness the conversion of electrical energy to thermal energy! You're seeing Joule heating in action - when current flows through resistance, electrical energy converts to heat energy. The multiple heating elements show realistic thermal radiation, convection currents, and even sparks. This principle is used in electric stoves, heaters, and countless other appliances. The amount of heat produced follows P equals I squared R.",
                    
                    // Electric Power
                    "This comprehensive power system shows electricity's journey from generation to consumption. Watch electricity flow from the power plant through transmission lines to distribution networks and finally to homes and businesses. The power equation P equals V I shows how electrical power depends on both voltage and current. Notice the transformers that step voltage up for efficient transmission and down for safe household use."
                ];
                
                const message = narrations[index] || "Exploring electrical concepts.";
                
                // Use Cartesia TTS for high-quality narration
                if (window.cartesiaTTS) {
                    window.cartesiaTTS.speak(message);
                }
                
                // Visual feedback during narration
                const activeSection = document.querySelector('.content-section.active');
                if (activeSection) {
                    activeSection.style.backgroundColor = '#001122';
                    activeSection.style.transition = 'background-color 0.5s ease';
                    
                    setTimeout(() => {
                        activeSection.style.backgroundColor = '';
                    }, 2000);
                }
            }
        }
        
        // Global control functions
        function resetCameraView(vizName) {
            if (window.experience && window.experience.cameras[vizName]) {
                const camera = window.experience.cameras[vizName];
                const controls = window.experience.controls[vizName];
                
                camera.position.set(0, 0, 5);
                camera.lookAt(0, 0, 0);
                controls.reset();
            }
        }
        
        function toggleAnimation(vizName) {
            if (window.experience && window.experience.animationStates[vizName]) {
                const state = window.experience.animationStates[vizName];
                state.playing = !state.playing;
                
                const button = document.getElementById(`${vizName}-play`);
                if (button) {
                    button.textContent = state.playing ? '⏸' : '▶';
                }
            }
        }
        
        // Global functions for buttons
        function nextSection() {
            if (window.experience) {
                window.experience.nextSection();
            }
        }
        
        function showCompletion() {
            if (window.experience) {
                window.experience.showCompletion();
            }
        }
        
        function restartExperience() {
            if (window.experience) {
                window.experience.restartExperience();
            }
        }
        
        function exploreMore() {
            if (window.experience) {
                window.experience.exploreMore();
            }
        }
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.experience = new ElectricalConceptsExperience();
        });

        // Modal functions
        function openDemoModal(url, title) {
            const modal = document.getElementById('demo-modal');
            const frame = document.getElementById('demo-frame');
            const titleElement = document.getElementById('demo-modal-title');
            
            titleElement.textContent = title;
            
            // Add loading feedback
            frame.style.background = 'var(--primary)';
            frame.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text); font-size: 1.2rem; font-family: Inter, sans-serif;"><div>Loading demo...<div style="margin-top: 1rem; width: 40px; height: 40px; border: 3px solid var(--accent); border-top: 3px solid transparent; border-radius: 50%; animation: spin 1s linear infinite; margin: 1rem auto;"></div></div></div>';
            
            // Show modal immediately
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
            
            // Load content with improved error handling
            setTimeout(() => {
                try {
                    // Reset iframe completely
                    frame.src = '';
                    frame.style.width = '100%';
                    frame.style.height = 'calc(100% - 80px)';
                    frame.style.border = 'none';
                    frame.style.background = 'white';
                    
                    let hasLoaded = false;
                    
                    // Set a shorter timeout to detect if iframe fails to load
                    const timeoutId = setTimeout(() => {
                        if (!hasLoaded) {
                            showFallbackOption(frame, url, title);
                        }
                    }, 3000); // Reduced to 3 seconds
                    
                    frame.onload = () => {
                        hasLoaded = true;
                        clearTimeout(timeoutId);
                        frame.style.background = 'white';
                        console.log('Iframe loaded successfully:', url);
                    };
                    
                    frame.onerror = () => {
                        hasLoaded = true;
                        clearTimeout(timeoutId);
                        showFallbackOption(frame, url, title);
                        console.error('Iframe failed to load:', url);
                    };
                    
                    // Try to load the iframe
                    frame.src = url;
                    
                    // Additional check for iframe content
                    setTimeout(() => {
                        try {
                            if (!hasLoaded && frame.contentDocument === null) {
                                hasLoaded = true;
                                clearTimeout(timeoutId);
                                showFallbackOption(frame, url, title);
                            }
                        } catch (e) {
                            // Cross-origin error is expected, means iframe is loading external content
                            console.log('Cross-origin iframe detected (normal)');
                        }
                    }, 1500);
                    
                } catch (error) {
                    console.error('Error setting up iframe:', error);
                    showFallbackOption(frame, url, title);
                }
            }, 100);
        }
        
        function showFallbackOption(frame, url, title) {
            frame.innerHTML = `
                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text); font-size: 1.2rem; font-family: Inter, sans-serif; text-align: center; padding: 2rem;">
                    <div style="margin-bottom: 2rem;">
                        <div style="font-size: 3rem; margin-bottom: 1rem;">🔗</div>
                        <div>Demo loading in new tab</div>
                        <div style="font-size: 1rem; color: #888; margin-top: 0.5rem;">Click below to access the interactive demo</div>
                    </div>
                    <button onclick="window.open('${url}', '_blank'); closeDemoModal();" 
                            style="background: var(--accent); color: white; border: none; padding: 1rem 2rem; border-radius: 8px; font-size: 1rem; cursor: pointer; transition: all 0.3s; margin-bottom: 1rem;">
                        Open ${title} →
                    </button>
                    <button onclick="retryIframe('${url}', '${title}')" 
                            style="background: transparent; color: var(--accent); border: 2px solid var(--accent); padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.9rem; cursor: pointer; transition: all 0.3s;">
                        Try Again in Modal
                    </button>
                </div>
            `;
        }
        
        function retryIframe(url, title) {
            openDemoModal(url, title);
        }
        
        function closeDemoModal() {
            const modal = document.getElementById('demo-modal');
            const frame = document.getElementById('demo-frame');
            
            modal.classList.remove('active');
            
            // Reset iframe content and styles
            frame.src = '';
            frame.innerHTML = '';
            frame.style.background = '';
            frame.onload = null;
            frame.onerror = null;
            
            // Re-enable background scrolling
            document.body.style.overflow = 'auto';
        }
        
        // Close modal on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeDemoModal();
            }
        });
        
        // Close modal on background click
        document.getElementById('demo-modal').addEventListener('click', (e) => {
            if (e.target.id === 'demo-modal') {
                closeDemoModal();
            }
        });
    </script>
</body>
</html> 